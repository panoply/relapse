(function () {
  'use strict';

  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // ../../spx/index.js
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a2, b3) => {
    for (var prop in b3 || (b3 = {}))
      if (__hasOwnProp.call(b3, prop))
        __defNormalProp(a2, prop, b3[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b3)) {
        if (__propIsEnum.call(b3, prop))
          __defNormalProp(a2, prop, b3[prop]);
      }
    return a2;
  };
  var __spreadProps = (a2, b3) => __defProps(a2, __getOwnPropDescs(b3));
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var w = typeof window !== "undefined" ? window : { screen: {}, navigator: {} };
  var matchMedia2 = (w.matchMedia || function() {
    return { matches: false };
  }).bind(w);
  var options = {
    get passive() {
      return true;
    }
  };
  var noop = function() {
  };
  w.addEventListener && w.addEventListener("p", noop, options);
  w.removeEventListener && w.removeEventListener("p", noop, false);
  var onTouchStartInWindow = "ontouchstart" in w;
  var touchEventInWindow = "TouchEvent" in w;
  var supportsTouchEvents = onTouchStartInWindow || touchEventInWindow && matchMedia2("(any-pointer: coarse)").matches;
  var hasTouch = (w.navigator.maxTouchPoints || 0) > 0 || supportsTouchEvents;
  var userAgent = w.navigator.userAgent || "";
  var isIPad = matchMedia2("(pointer: coarse)").matches && // both iPad and iPhone can "request desktop site", which sets the userAgent to Macintosh
  // so need to check both userAgents to determine if it is an iOS device
  // and screen size to separate iPad from iPhone
  /iPad|Macintosh/.test(userAgent) && Math.min(w.screen.width || 0, w.screen.height || 0) >= 768;
  var hasCoarsePrimaryPointer = (matchMedia2("(pointer: coarse)").matches || // if the pointer is not coarse and not fine then the browser doesn't support
  // interaction media queries (see https://caniuse.com/css-media-interaction)
  // so if it has onTouchStartInWindow assume it has a coarse primary pointer
  !matchMedia2("(pointer: fine)").matches && onTouchStartInWindow) && // bug in firefox (as of v81) on hybrid windows devices where the interaction media queries
  // always indicate a touch only device (only has a coarse pointer that can't hover)
  // so assume that the primary pointer is not coarse for firefox windows
  !/Windows.*Firefox/.test(userAgent);
  var hasAnyHoverOrAnyFinePointer = matchMedia2("(any-pointer: fine)").matches || matchMedia2("(any-hover: hover)").matches || // iPads might have an input device that can hover, so assume it has anyHover
  isIPad || // if no onTouchStartInWindow then the browser is indicating that it is not a touch only device
  // see above note for supportsTouchEvents
  !onTouchStartInWindow;
  var deviceType = hasTouch && (hasAnyHoverOrAnyFinePointer || !hasCoarsePrimaryPointer) ? "hybrid" : hasTouch ? "touchOnly" : "mouseOnly";
  var isBrowser = typeof window !== "undefined";
  "content" in document.createElement("template");
  document.createRange && "createContextualFragment" in document.createRange();
  var pointer = supportsTouchEvents ? "pointer" : "mouse";
  var origin = window.location.origin;
  var object = Object.create;
  var nil = "";
  var { warn, info, error, debug } = console;
  var d = () => document.documentElement;
  var b = () => document.body;
  var h = () => document.head;
  var o = (value) => value ? Object.assign(object(null), value) : object(null);
  var s = (value) => new Set(value);
  var p = (handler) => new Proxy(o(), handler);
  var m = () => /* @__PURE__ */ new Map();
  var XHR = class extends XMLHttpRequest {
    constructor() {
      super(...arguments);
      this.key = null;
    }
  };
  XHR.$request = m();
  XHR.$transit = m();
  XHR.$timeout = {};
  var $ = o({
    index: "",
    eval: true,
    patched: false,
    loaded: false,
    logLevel: 2,
    qs: o(),
    config: o({
      fragments: ["body"],
      timeout: 3e4,
      globalThis: true,
      schema: "spx-",
      logLevel: 3,
      cache: true,
      components: null,
      maxCache: 100,
      reverse: true,
      preload: null,
      annotate: false,
      eval: o({
        script: null,
        style: null,
        link: null,
        meta: false
      }),
      hover: o({
        trigger: "href",
        threshold: 250
      }),
      intersect: o({
        rootMargin: "0px 0px 0px 0px",
        threshold: 0
      }),
      proximity: o({
        distance: 75,
        threshold: 250,
        throttle: 500
      }),
      progress: o({
        bgColor: "#111",
        barHeight: "3px",
        minimum: 0.08,
        easing: "linear",
        speed: 200,
        threshold: 500,
        trickle: true,
        trickleSpeed: 200
      })
    }),
    fragments: m(),
    components: o({
      $bindings: m(),
      $mounted: s(),
      $registry: m(),
      $instances: m(),
      $reference: p({
        get: (map, key) => $.components.$instances.get(map[key])
      })
    }),
    events: o(),
    observe: o(),
    memory: o(),
    pages: o(),
    snaps: o(),
    resources: s()
  });
  var PREFIX = "SPX ";
  var log = (type, message, context2) => {
    const LEVEL = $.logLevel;
    if (LEVEL > 2 && type <= 2)
      return;
    if (Array.isArray(message))
      message = message.join(" ");
    if ((type === 2 || type === 1) && (LEVEL === 1 || LEVEL === 2)) {
      info(`${PREFIX}%c${message}`, `color: ${context2 || "#999"};`);
    } else if (type === 3 && LEVEL <= 3) {
      if (context2) {
        warn(PREFIX + message, context2);
      } else {
        warn(PREFIX + message);
      }
    } else if (type === 5 || type === 4) {
      if (context2) {
        error(PREFIX + message, context2);
      } else {
        error(PREFIX + message);
      }
      try {
        if (type === 4) {
          throw new TypeError(message);
        } else {
          throw new Error(message);
        }
      } catch (e2) {
      }
    }
  };
  function forEach(cb, array) {
    if (arguments.length === 1)
      return (a2) => forEach(cb, a2);
    const s2 = array.length;
    if (s2 === 0)
      return;
    let r, i2 = 0;
    for (; i2 < s2; i2++) {
      r = cb(array[i2], i2, array);
      if (r === false)
        break;
    }
    return r;
  }
  var splitAttrArrayValue = (input2) => {
    let v2 = input2.replace(/\s+,/g, ",").replace(/,\s+/g, ",").replace(/['"]/g, "");
    if (v2.charCodeAt(0) === 91 && (/^\[\s*\[/.test(v2) || /,/.test(v2) && /\]$/.test(v2))) {
      v2 = v2.replace(/^\[/, "").replace(/\]$/, "");
    }
    return v2.split(/,|\|/);
  };
  var attrJSON = (attr, string) => {
    try {
      const json = (string || attr).replace(/\\'|'/g, (m2) => m2[0] === "\\" ? m2 : '"').replace(/"(?:\\.|[^"])*"/g, (m2) => m2.replace(/\n/g, "\\n")).replace(
        /\[|[^[\]]*|\]/g,
        (m2) => /[[\]]/.test(m2) ? m2 : m2.split(",").map((value) => value.replace(/^(\w+)$/, '"$1"').replace(/^"([\d.]+)"$/g, "$1")).join(",")
      ).replace(/([a-zA-Z0-9_-]+)\s*:/g, '"$1":').replace(/:\s*([$\w-]+)\s*([,\]}])/g, ':"$1"$2').replace(/,(\s*[\]}])/g, "$1").replace(/([a-zA-Z_-]+)\s*,/g, '"$1",').replace(/([\]},\s]+)?"(true|false)"([\s,{}\]]+)/g, "$1$2$3");
      return JSON.parse(json);
    } catch (e2) {
      log(5, "Invalid JSON in attribute value: " + JSON.stringify(attr || string, null, 2), e2);
      return string;
    }
  };
  var last = (input2) => input2[input2.length - 1];
  var equalizeWS = (input2) => input2.replace(/\s+/g, " ").trim();
  var escSelector = (input2) => input2.replace(/\./g, "\\.").replace(/@/g, "\\@").replace(/:/g, "\\:");
  var onNextTickResolve = () => new Promise((resolve) => setTimeout(() => resolve(), 1));
  var onNextTick = (cb, timeout = 1, bind) => setTimeout(() => cb(), timeout);
  var promiseResolve = () => Promise.resolve();
  var canEval = (element2) => {
    switch (element2.nodeName) {
      case "SCRIPT":
        return element2.matches($.qs.$script);
      case "STYLE":
        return element2.matches($.qs.$script);
      case "META":
        return element2.matches($.qs.$meta);
      case "LINK":
        return element2.matches($.qs.$link);
      default:
        return element2.getAttribute($.qs.$eval) !== "false";
    }
  };
  var decodeEntities = (string) => {
    const textarea2 = document.createElement("textarea");
    textarea2.innerHTML = string;
    return textarea2.value;
  };
  var ts = () => (/* @__PURE__ */ new Date()).getTime();
  var hasProps = (object2) => {
    const typeOf = typeof object2 === "object";
    return (property) => typeOf ? !property ? false : typeof property === "string" ? property in object2 : property.every((p22) => p22 ? p22 in object2 : false) : false;
  };
  var hasProp = (object2, property) => typeof object2 === "object" && typeof property === "string" ? property in object2 : false;
  var defineGetter = (object2, name, value, configurable = null) => configurable !== null ? name in object2 ? object2 : Object.defineProperty(object2, name, { get: () => value, configurable }) : Object.defineProperty(object2, name, { get: () => value });
  var defineGetterProps = (object2, props) => forEach(([name, get2]) => Object.defineProperty(object2, name, { get: get2 }), props);
  var targets = (page) => {
    if ("target" in page) {
      if (page.target.length === 1 && page.target[0] === "body")
        return page.target;
      if (page.target.includes("body")) {
        log(3, `The body selector passed via ${$.qs.$target} will override`);
        return ["body"];
      }
      return page.target.filter((v2, i2, a2) => v2 !== "" && v2.indexOf(",") === -1 ? a2.indexOf(v2) === i2 : false);
    } else if ($.config.fragments.length === 1 && $.config.fragments[0] === "body") {
      return ["body"];
    }
    return [];
  };
  var selector = (target) => target.length === 1 && target[0] === "body" ? "body" : target.length === 0 ? null : target.join(",");
  var isEmpty = (input2) => {
    const T2 = typeof input2;
    if (T2 === "object") {
      for (const _ in input2)
        return false;
      return true;
    }
    return T2 === "string" ? input2[0] === void 0 : Array.isArray(input2) ? input2.length > 0 : null;
  };
  var glue = (...input2) => input2.join(nil);
  var uuid = function uuid2(s2 = 5) {
    const k2 = Math.random().toString(36).slice(-s2);
    if (uuid2.$cache.has(k2))
      return uuid2(s2);
    uuid2.$cache.add(k2);
    return k2;
  };
  uuid.$cache = s();
  var chunk = (size2 = 2) => (acc, value) => {
    const length = acc.length;
    const chunks = length < 1 || acc[length - 1].length === size2 ? acc.push([value]) : acc[length - 1].push(value);
    return chunks && acc;
  };
  var size = (bytes) => bytes < 1024 ? bytes + " B" : bytes < 1048576 ? (bytes / 1024).toFixed(1) + " KB" : bytes < 1073741824 ? (bytes / 1048576).toFixed(1) + " MB" : (bytes / 1073741824).toFixed(1) + " GB";
  var downcase = (input2) => input2[0].toLowerCase() + input2.slice(1);
  var upcase = (input2) => input2[0].toUpperCase() + input2.slice(1);
  var kebabCase = (input2) => /[A-Z]/.test(input2) ? input2.replace(/(.{1})([A-Z])/g, "$1-$2").toLowerCase() : input2;
  var camelCase = (input2) => /[_-]/.test(downcase(input2)) ? input2.replace(/([_-]+).{1}/g, (x2, k2) => x2[k2.length].toUpperCase()) : input2;
  var nodeSet = (nodes) => s([].slice.call(nodes));
  var forNode = (selector2, cb) => {
    const nodes = typeof selector2 === "string" ? b().querySelectorAll(selector2) : selector2;
    const count = nodes.length;
    if (count === 0)
      return;
    for (let i2 = 0; i2 < count; i2++)
      if (cb(nodes[i2], i2) === false)
        break;
  };
  var empty = (object2) => {
    for (const prop in object2)
      delete object2[prop];
  };
  var enqueue = /* @__PURE__ */ ((queue) => {
    const promise = (fn2) => new Promise((resolve) => resolve(fn2()));
    const process = (batch = 2, delay = 200) => __async(void 0, null, function* () {
      while (queue.length > 0) {
        for (const fn2 of queue.splice(0, batch))
          yield promise(fn2);
        yield new Promise((resolve) => setTimeout(resolve, delay));
      }
    });
    return (...fn2) => {
      fn2.forEach((cb) => queue.push(cb));
      onNextTick(() => process(), 50);
    };
  })([]);
  var patchSetAttribute = () => {
    if ($.patched)
      return;
    $.patched = true;
    const n = Element.prototype.setAttribute;
    const e2 = document.createElement("i");
    Element.prototype.setAttribute = function setAttribute(name, value) {
      if (name.indexOf("@") < 0)
        return n.call(this, name, value);
      e2.innerHTML = `<i ${name}="${value}"></i>`;
      const attr = e2.firstElementChild.getAttributeNode(name);
      e2.firstElementChild.removeAttributeNode(attr);
      this.setAttributeNode(attr);
    };
  };
  var progress = (() => {
    const pending = [];
    const node = document.createElement("div");
    let status = null;
    let timeout;
    let element2 = null;
    const style = ({ bgColor, barHeight, speed, easing }) => {
      node.style.cssText = glue(
        "pointer-events:none;",
        `background-color:${bgColor};`,
        `height:${barHeight};`,
        "position:fixed;",
        "display:block;",
        "z-index:2147483647;",
        "top:0;",
        "left:0;",
        "width:100%;",
        "will-change:opacity,transform;",
        `transition:transform ${speed}ms ${easing};`
      );
    };
    const percent = (n) => (-1 + n) * 100;
    const current = (n, min, max) => n < min ? min : n > max ? max : n;
    const render2 = () => {
      if (element2)
        return element2;
      node.style.setProperty("transform", `translateX(${percent(status || 0)}%)`);
      element2 = b().appendChild(node);
      return node;
    };
    const remove = () => {
      const dom = b();
      if (dom.contains(element2)) {
        const animate = element2.animate(
          { opacity: ["1", "0"] },
          { easing: "ease-out", duration: 100 }
        );
        animate.onfinish = () => {
          dom.removeChild(element2);
          element2 = null;
        };
      } else {
        element2 = null;
      }
    };
    const dequeue = () => {
      const update3 = pending.shift();
      if (update3)
        update3(dequeue);
    };
    const enqueue2 = (call) => {
      pending.push(call);
      if (pending.length === 1)
        dequeue();
    };
    const set2 = (amount) => {
      amount = current(amount, $.config.progress.minimum, 1);
      status = amount === 1 ? null : amount;
      const progress2 = render2();
      enqueue2((update3) => {
        progress2.style.setProperty("transform", `translateX(${percent(amount)}%)`);
        if (amount === 1) {
          setTimeout(() => {
            remove();
            update3();
          }, $.config.progress.speed * 2);
        } else {
          setTimeout(update3, $.config.progress.speed);
        }
      });
    };
    const inc = (amount) => {
      let n = status;
      if (!n)
        return start();
      if (n < 1) {
        if (typeof amount !== "number") {
          if (n >= 0 && n < 0.2)
            amount = 0.1;
          else if (n >= 0.2 && n < 0.5)
            amount = 0.04;
          else if (n >= 0.5 && n < 0.8)
            amount = 0.02;
          else if (n >= 0.8 && n < 0.99)
            amount = 5e-3;
          else
            amount = 0;
        }
        n = current(n + amount, 0, 0.994);
        return set2(n);
      }
    };
    const doTrickle = () => {
      setTimeout(() => {
        if (!status)
          return;
        inc();
        doTrickle();
      }, $.config.progress.trickleSpeed);
    };
    const start = (threshold) => {
      if (!$.config.progress)
        return;
      timeout = setTimeout(() => {
        if (!status)
          set2(0);
        if ($.config.progress.trickle)
          doTrickle();
      }, threshold || 0);
    };
    const done = (force) => {
      clearTimeout(timeout);
      if (!force && !status)
        return;
      inc(0.3 + 0.5 * Math.random());
      set2(1);
    };
    return {
      start,
      done,
      style
    };
  })();
  var getComponentId = (instance, identifier) => {
    const name = instance.name;
    const original = identifier;
    identifier = downcase(identifier || name);
    instance.define = Object.assign({ id: identifier, merge: false, state: {}, nodes: [] }, instance.define);
    if (identifier !== instance.define.id)
      identifier = camelCase(instance.define.id);
    if (name !== original && /^[A-Z]|[_-]/.test(instance.define.id)) {
      log(3, [
        `Component identifer id "${instance.define.id}" must use camelCase format.`,
        `The identifer has been converted to "${identifier}"`
      ]);
    }
    return identifier;
  };
  var registerComponents = (components, isValidID = false) => {
    const { $registry } = $.components;
    for (const id in components) {
      const instance = components[id];
      const identifier = isValidID ? id : getComponentId(instance, id);
      if (!$registry.has(identifier)) {
        $registry.set(identifier, instance);
        log(
          1,
          `Component ${instance.name} registered using id: ${identifier}`,
          "#F48FB1"
          /* PINK */
        );
      }
    }
    if (!$.config.components)
      $.config.components = true;
  };
  var parse = (HTMLString) => new DOMParser().parseFromString(HTMLString, "text/html");
  var takeSnapshot = (dom) => (dom || document).documentElement.outerHTML;
  var getTitle = (dom) => {
    const title = dom.indexOf("<title");
    if (title === -1)
      return nil;
    if (dom.slice(0, title).indexOf("<svg") > -1)
      return nil;
    const start = dom.indexOf(">", title) + 1;
    const end = dom.indexOf("</title", start);
    return decodeEntities(dom.slice(start, end).trim());
  };
  var element = (selector2, el) => el.querySelector(selector2);
  var elements = (selector2, el) => [].slice.call(el.querySelectorAll(selector2)) || [];
  function emit(name, ...args) {
    const isCache = name === "before:cache";
    if (isCache)
      args[1] = parse(args[1]);
    let returns = true;
    forEach((argument) => {
      const returned = argument.apply(null, args);
      if (isCache) {
        if (returned instanceof Document) {
          returns = returned.documentElement.outerHTML;
        } else {
          if (typeof returns !== "string")
            returns = returned !== false;
        }
      } else {
        returns = returned !== false;
      }
    }, $.events[name] || []);
    return returns;
  }
  var on = (name, callback, scope) => {
    if (!(name in $.events))
      $.events[name] = [];
    return $.events[name].push(scope ? callback.bind(scope) : callback) - 1;
  };
  var off = (name, callback) => {
    if (name in $.events) {
      const events = $.events[name];
      if (events && typeof callback === "number") {
        events.splice(callback, 1);
        log(2, `Removed ${name} event listener (id: ${callback})`);
        if (events.length === 0)
          delete $.events[name];
      } else {
        const live = [];
        if (events && callback) {
          for (let i2 = 0, s2 = events.length; i2 < s2; i2++) {
            if (events[i2] !== callback) {
              live.push(events[i2]);
            } else if (name !== "x") {
              log(2, `Removed ${name} event listener (id: ${i2})`);
            }
          }
        }
        if (live.length) {
          $.events[name] = live;
        } else {
          delete $.events[name];
        }
      }
    } else {
      log(3, `There are no ${name} event listeners`);
    }
    return void 0;
  };
  var walkElements = (node, callback) => {
    const cb = callback(node);
    if (cb === false)
      return;
    if (cb === 1)
      node = node.nextSibling;
    let e2;
    let i2;
    if (node.firstElementChild) {
      i2 = 0;
      e2 = node.children[i2];
    }
    while (e2) {
      if (e2)
        walkElements(e2, callback);
      e2 = node.children[++i2];
    }
  };
  var isValidEvent = (eventName, node) => {
    if (`on${eventName}` in node)
      return true;
    log(5, [
      `Invalid event name "${eventName}" provided. No such event exists in the DOM API.`,
      "Only known event listeners can be attached."
    ], node);
    return false;
  };
  var eventAttrs = (instance, event) => {
    const method = instance[event.method];
    return function handle2(e2) {
      if (event.params)
        e2.attrs = event.params;
      method.call(instance, e2);
    };
  };
  var removeEvent = (instance, event) => {
    if (!event.attached)
      return;
    event.listener.abort();
    event.listener = new AbortController();
    event.options.signal = event.listener.signal;
    event.attached = false;
    log(1, [
      `Detached ${event.key} ${event.eventName} event from ${event.method}() method in component`,
      `${instance.scope.define.id}: ${instance.scope.key}`
    ]);
  };
  var addEvent = (instance, event, node) => {
    if (event.attached)
      return;
    if (!(event.method in instance)) {
      log(3, `Undefined callback method: ${instance.scope.define.id}.${event.method}()`);
      return;
    }
    const dom = node ? defineGetter(event, "dom", node).dom : event.dom;
    getEventParams(dom.attributes, event);
    console.log(event);
    if (event.isWindow) {
      if (isValidEvent(event.eventName, window)) {
        addEventListener(event.eventName, eventAttrs(instance, event));
      }
    } else {
      if (isValidEvent(event.eventName, dom)) {
        dom.addEventListener(event.eventName, eventAttrs(instance, event), event.options);
      }
    }
    event.attached = true;
    log(1, [
      `Attached ${event.key} ${event.eventName} event to ${event.method}() method in component`,
      `${instance.scope.define.id}: ${instance.scope.key}`
    ]);
  };
  var _a;
  var Component = (_a = class {
    /**
     * Constructor
     *
     * Creates the component instance
     */
    constructor(value) {
      this.dom = o();
      Reflect.defineProperty(this, "ref", { value, configurable: false, enumerable: false, writable: false });
      const { scope, root } = this;
      const prefix = `${$.config.schema}${scope.instanceOf}`;
      this.state = new Proxy(scope.state, {
        get: Reflect.get,
        set(target, key, value2, receiver) {
          const domValue = typeof value2 === "object" || Array.isArray(value2) ? JSON.stringify(value2) : `${value2}`;
          if (root && domValue.trim() !== "") {
            const camelCase2 = `${prefix}:${key}`;
            const attrName = root.hasAttribute(camelCase2) ? camelCase2 : `${prefix}:${kebabCase(key)}`;
            domValue === root.getAttribute(attrName) || root.setAttribute(attrName, domValue);
          }
          if (key in scope.binds) {
            const binding = scope.binds[key];
            for (const id in binding) {
              if (!binding[id].live)
                continue;
              binding[id].value = domValue;
              forNode(binding[id].selector, (node) => {
                node.innerText = domValue;
              });
            }
          }
          return Reflect.set(target, key, value2, receiver);
        }
      });
      if (isEmpty(scope.state)) {
        for (const prop in scope.define.state) {
          const attr = scope.define.state[prop];
          let type = attr;
          let value2;
          if (typeof attr === "object") {
            type = attr.typeof;
            value2 = attr.default;
          }
          switch (type) {
            case String:
              scope.state[prop] = value2 || nil;
              break;
            case Boolean:
              scope.state[prop] = typeof value2 === "boolean" ? value2 : value2 === "true" || false;
              break;
            case Number:
              scope.state[prop] = value2 ? Number(value2) : 0;
              break;
            case Object:
              scope.state[prop] = typeof value2 === "object" ? value2 : {};
              break;
            case Array:
              scope.state[prop] = Array.isArray(value2) ? value2 : [];
              break;
          }
        }
      } else {
        for (const prop in scope.define.state) {
          const attr = scope.define.state[prop];
          if (!(prop in scope.state)) {
            if (typeof attr === "object") {
              scope.state[prop] = attr.default;
            } else {
              switch (attr) {
                case String:
                  scope.state[prop] = "";
                  break;
                case Boolean:
                  scope.state[prop] = false;
                  break;
                case Number:
                  scope.state[prop] = 0;
                  break;
                case Object:
                  scope.state[prop] = {};
                  break;
                case Array:
                  scope.state[prop] = [];
                  break;
              }
            }
          }
          const attrName = kebabCase(prop);
          const hasProp2 = `has${upcase(prop)}`;
          let type = attr;
          let value2 = root.hasAttribute(`${prefix}:${attrName}`) ? root.getAttribute(`${prefix}:${attrName}`) : root.getAttribute(`${prefix}:${prop}`);
          const defined = value2 !== null && value2 !== "";
          if (typeof attr === "object") {
            type = attr.typeof;
            if (!defined)
              value2 = attr.default;
          }
          hasProp2 in scope.state || defineGetter(scope.state, hasProp2, defined);
          if (typeof value2 === "string" && value2.startsWith("window.")) {
            scope.state[prop] = window[value2.slice(7)];
          } else {
            switch (type) {
              case String:
                scope.state[prop] = value2 || "";
                break;
              case Boolean:
                scope.state[prop] = typeof value2 === "boolean" ? value2 : value2 === "true" || false;
                break;
              case Number:
                scope.state[prop] = value2 ? Number(value2) : 0;
                break;
              case Object:
                scope.state[prop] = defined ? attrJSON(value2) : value2 || {};
                break;
              case Array:
                scope.state[prop] = defined ? attrJSON(value2) : value2 || [];
                break;
            }
          }
        }
      }
    }
    /**
     * **SPX Document Element**
     *
     * Holds a reference to the DOM Document element `<html>` node.
     */
    get html() {
      return d();
    }
    /**
     * **SPX Component Element**
     *
     * Holds a reference to the DOM Document element `<div spx-component="">` node.
     */
    get root() {
      return this.scope.root;
    }
    /**
     * **SPX Component Element (setter)**
     *
     * Resets the root componet node
     */
    set root(node) {
      defineGetter(this.scope, "root", node);
    }
    /**
     * Component Scope
     *
     * Holds scope reference information about the instance, elements which pertain to the instance
     * and event reference handling.
     */
    get scope() {
      return Component.scopes.get(this.ref);
    }
  }, /**
  * Component Scopes
  *
  * Isolated store of all component instance scopes. Available to component instances
  * via the getter `scope` property. This reference acts as the generation guideline
  * for component instances.
  */
  _a.scopes = m(), _a);
  var components_exports = {};
  __export(components_exports, {
    connect: () => connect2,
    disconnect: () => disconnect2,
    hargs: () => hargs,
    hook: () => hook,
    mount: () => mount,
    teardown: () => teardown
  });
  var context;
  var mark = s();
  var resetContext = () => onNextTick(() => context = void 0);
  var connect = (node, refs) => {
    for (const id of refs) {
      if (!$.components.$reference[id])
        continue;
      const instance = $.components.$reference[id];
      const ref = id.charCodeAt(0);
      if (ref === 99) {
        $.components.$mounted.add(instance.scope.key);
        instance.root = node;
        instance.scope.status = 2;
        log(
          1,
          `Component ${instance.scope.define.id} mounted: ${instance.scope.key}`,
          "#6DD093"
          /* GREEN */
        );
      } else if (ref === 101) {
        addEvent(instance, instance.scope.events[id], node);
      } else if (ref === 110) {
        for (const k2 in instance.scope.nodes) {
          instance.scope.nodes[k2].live++;
        }
      } else if (ref === 98) {
        for (const k2 in instance.scope.binds) {
          if (id in instance.scope.binds[k2]) {
            node.innerText = instance.scope.binds[k2][id].value;
            instance.scope.binds[k2][id].live = true;
            break;
          }
        }
      }
    }
  };
  var disconnect = (curNode, refs, newNode) => {
    for (const id of refs) {
      if (!$.components.$reference[id])
        continue;
      const instance = $.components.$reference[id];
      const ref = id.charCodeAt(0);
      if (ref === 99) {
        instance.scope.hooks.unmount === 2 && instance.unmount(hargs());
        $.components.$mounted.delete(instance.scope.key);
        if (instance.scope.define.merge) {
          instance.scope.snapshot = curNode.innerHTML;
          log(
            1,
            `Component ${instance.scope.define.id} snapshot: ${instance.scope.key}`,
            "#999"
            /* GRAY */
          );
        }
        for (const k2 in instance.scope.nodes) {
          instance.scope.nodes[k2].live = 0;
        }
        for (const k2 in instance.scope.binds) {
          for (const uuid3 in instance.scope.binds[k2]) {
            instance.scope.binds[k2][uuid3].live = false;
          }
        }
        for (const key in instance.scope.events) {
          removeEvent(instance, instance.scope.events[key]);
        }
        instance.scope.status = 5;
        log(
          1,
          `Component ${instance.scope.define.id} unmounted: ${instance.scope.key}`,
          "#7b97ca"
          /* PURPLE */
        );
      } else if (ref === 101) {
        removeEvent(instance, instance.scope.events[id]);
      } else if (ref === 110) {
        for (const k2 in instance.scope.nodes) {
          --instance.scope.nodes[k2].live;
        }
      } else if (ref === 98) {
        for (const k2 in instance.scope.binds) {
          if (id in instance.scope.binds[k2]) {
            instance.scope.binds[k2][id].live = false;
            break;
          }
        }
      }
    }
  };
  var removeNode = (node) => {
    if (node.nodeType !== 1 && node.nodeType !== 11)
      return;
    const attrs = node.getAttribute($.qs.$ref);
    attrs && disconnect(node, attrs.split(","));
  };
  var addedNode = (node) => {
    const attrs = node.getAttribute($.qs.$ref);
    if (attrs) {
      connect(node, attrs.split(","));
    } else {
      if (isDirective(node.attributes)) {
        context ? context.$morph = node : context = getContext(node);
        walkNode(node, context);
      }
    }
  };
  var readNode = (newNode) => {
    context ? context.$morph = newNode : context = getContext(newNode);
    walkNode(newNode, context, false);
  };
  var updateNode = (curNode, newNode, cRef, nRef) => {
    if (cRef)
      cRef = cRef.split(",");
    if (nRef)
      nRef = nRef.split(",");
    if (cRef && nRef) {
      disconnect(curNode, cRef);
      connect(curNode, nRef);
    } else if (!cRef && nRef) {
      connect(curNode, nRef);
    } else {
      context ? context.$morph = curNode : context = getContext(curNode, newNode);
      if (cRef && !nRef)
        disconnect(curNode, cRef);
      if (isDirective(newNode.attributes))
        walkNode(curNode, context);
    }
  };
  var patchComponentSnap = (scope, scopeKey) => onNextTick(() => {
    const snap2 = getSnapDom(scope.snap);
    const elem = snap2.querySelector(`[${$.qs.$ref}="${scope.ref}"]`);
    if (elem) {
      elem.innerHTML = scope.snapshot;
      setSnap(elem.ownerDocument.documentElement.outerHTML, scope.snap);
    } else {
      log(3, `Component snapshot merge failed: ${scope.instanceOf} (${scopeKey})`);
    }
  });
  var morphHead = (method, newNode) => {
    const { page, dom } = get($.page.key);
    const operation = method.charCodeAt(0) === 114 ? "removed" : "appended";
    if (dom.head.contains(newNode)) {
      dom.head[method](newNode);
      $.snaps[page.snap] = dom.documentElement.outerHTML;
      log(1, `Snapshot record was updated. Node ${operation} from <head>`, newNode);
    } else {
      log(3, "Node does not exist in the snapshot record, no mutation applied", newNode);
    }
  };
  var hargs = () => o({ page: o($.page) });
  var teardown = () => {
    for (const ref in $.components.$reference) {
      delete $.components.$reference[ref];
    }
    for (const instance of $.components.$instances.values()) {
      for (const key in instance.scope.events) {
        removeEvent(instance, instance.scope.events[key]);
      }
    }
    $.components.$instances.clear();
    $.components.$mounted.clear();
    log(2, "Component instances were disconnected");
  };
  var mount = (promises) => {
    const params = hargs();
    const promise = [];
    for (const [ref, firsthook, finalhook] of promises) {
      const instance = $.components.$instances.get(ref);
      const MOUNT = instance.scope.status === 4 ? "unmount" : "onmount";
      if (!instance.scope.snap)
        instance.scope.snap = $.page.snap;
      const seq = () => __async(void 0, null, function* () {
        try {
          if (finalhook && instance.scope.status === 1) {
            yield instance[firsthook](params);
            yield instance[finalhook](params);
          } else {
            if (instance.scope.status === 4) {
              instance.scope.define.merge && patchComponentSnap(instance.scope, ref);
            } else {
              yield instance[firsthook](params);
            }
          }
          instance.scope.status = instance.scope.status === 4 ? 5 : 3;
          if (instance.scope.hooks.connect === 2) {
            instance.scope.hooks.connect = 3;
          }
        } catch (error2) {
          log(3, `Component to failed to ${MOUNT}: ${instance.scope.instanceOf} (${ref})`, error2);
          return Promise.reject(ref);
        }
      });
      promise.push(promiseResolve().then(seq));
    }
    return Promise.allSettled(promise);
  };
  var hook = () => {
    const { $mounted, $instances, $registry } = $.components;
    if ($mounted.size === 0 && $instances.size === 0 && $registry.size > 0)
      return getComponents();
    const promises = [];
    for (const ref of $mounted) {
      if (!$instances.has(ref))
        continue;
      const instance = $instances.get(ref);
      if (instance.scope.status !== 3 && instance.scope.status !== 5) {
        const unmount = instance.scope.status === 4;
        const trigger = unmount ? "unmount" : "onmount";
        if (trigger in instance) {
          trigger === "onmount" && "connect" in instance && instance.scope.hooks.connect === 2 ? promises.push([ref, "connect", trigger]) : promises.push([ref, trigger]);
        } else if (unmount) {
          instance.scope.define.merge && patchComponentSnap(instance.scope, ref);
          instance.scope.status = 5;
        }
      }
    }
    promises.length > 0 && mount(promises).catch((ref) => {
      const instance = $instances.get(ref);
      instance.scope.status = 5;
      $mounted.delete(ref);
    });
  };
  var connect2 = () => {
    if ($.components.$registry.size === 0 || $.observe.components)
      return;
    if ($.page.type === 0) {
      getComponents();
    } else {
      if (context) {
        setInstances(context).then(hook).then(resetContext);
      } else {
        hook();
      }
    }
    $.observe.components = true;
  };
  var disconnect2 = () => {
    if (!$.observe.components)
      return;
    hook();
    $.observe.components = false;
  };
  var snap = /* @__PURE__ */ ((cache) => {
    let record;
    const attr = (dom, refs) => dom.setAttribute($.qs.$ref, dom.hasAttribute($.qs.$ref) ? `${dom.getAttribute($.qs.$ref)},${refs.shift()}` : refs.shift());
    const set2 = (element2) => {
      cache.push([element2, m()]);
      record = cache[cache.length - 1][1];
      return element2;
    };
    const add = (selector2, ref, incremental = false) => record.has(selector2) ? record.get(selector2).push(ref) : record.set(selector2, [ref]);
    const sync = (snapshot, key) => enqueue(() => {
      while (cache.length > 0) {
        const [dom, marks] = cache.shift();
        for (const [selector2, refs] of marks) {
          dom.matches(selector2) && attr(dom, refs);
          dom.querySelectorAll(selector2).forEach((child) => attr(child, refs));
        }
        marks.clear();
      }
      setSnap(snapshot.documentElement.outerHTML, key);
      log(1, `Snapshot ${$.page.key} updated for: ${$.page.snap}`);
    });
    return { set: set2, add, sync };
  })([]);
  var setLifecyles = (scope, instance) => {
    scope.hooks = o();
    forEach((hook2) => {
      scope.hooks[hook2] = hook2 in instance ? 2 : 1;
    }, [
      "connect",
      "onmount",
      "unmount",
      "onmedia"
    ]);
  };
  var setTriggers = (promises, isMorph, isMount) => (instance, scope) => {
    if (isMorph === false || isMount && scope.status === 2) {
      $.components.$mounted.add(scope.key);
      $.components.$instances.set(scope.key, instance);
      log(
        1,
        `Component "${scope.instanceOf}" connected: ${scope.key}`,
        "#2cc9ee"
        /* CYAN */
      );
      let p22 = -1;
      if (scope.hooks.connect === 2) {
        p22 = promises.push([scope.key, "connect"]) - 1;
        scope.status = 1;
      }
      if (scope.hooks.onmount === 2) {
        p22 = (p22 > -1 ? promises[p22].push("onmount") : promises.push([scope.key, "onmount"])) - 1;
      }
      if (p22 < 0) {
        scope.status = 3;
      }
    }
  };
  var setEvents = (scope, instance, isMorph) => {
    for (const key in scope.events) {
      if (isMorph !== null && scope.status === 3) {
        $.components.$reference[key] = scope.key;
        instance.scope.events[key] = scope.events[key];
      }
      addEvent(instance, scope.events[key]);
    }
  };
  var setNodes = (nodes, instance) => {
    for (const key in nodes) {
      const node = nodes[key];
      if (node.schema[0] in instance.dom) {
        if (key in instance.scope.nodes)
          ++instance.scope.nodes[key].live;
      } else {
        Object.defineProperties(instance.dom, {
          [node.schema[0]]: { get: () => element(node.selector, node.isWithin ? instance.root : b()) },
          [node.schema[1]]: { get: () => elements(node.selector, node.isWithin ? instance.root : b()) },
          [node.schema[2]]: { get: () => node.live > 0 }
        });
      }
    }
  };
  var defineInstances = (promises, mounted2, isMorph) => {
    const isMount = isMorph || $.page.type === 4;
    const setHook = setTriggers(promises, isMorph, isMount);
    return (scope, instance) => {
      if (instance) {
        setNodes(scope.nodes, instance);
        setEvents(scope, instance, isMorph);
      } else {
        scope.define = o();
        const Component2 = $.components.$registry.get(scope.instanceOf);
        const Define = defineGetter(scope, "define", Component2.define);
        Component.scopes.set(scope.key, Define);
        const instance2 = new Component2(scope.key);
        setLifecyles(scope, instance2);
        setNodes(scope.nodes, instance2);
        setEvents(scope, instance2, isMorph);
        setHook(instance2, scope);
      }
    };
  };
  var setInstances = (context2, snapshot) => {
    const { $scopes, $aliases, $morph } = context2;
    const promises = [];
    const mounted2 = mounted();
    const define = defineInstances(promises, mounted2, $morph !== null);
    for (const instanceOf in $scopes) {
      if (!$.components.$registry.has(instanceOf) && !mounted2.has(instanceOf)) {
        log(3, `Component does not exist in registry: ${instanceOf}`, $scopes[instanceOf]);
        continue;
      }
      for (const scope of $scopes[instanceOf]) {
        if (scope.instanceOf == null) {
          if (instanceOf in $aliases) {
            scope.instanceOf = $aliases[instanceOf];
          } else {
            continue;
          }
        }
        if (mounted2.has(instanceOf)) {
          for (const instance of mounted2.get(instanceOf)) {
            if (instance.scope.instanceOf === instanceOf) {
              if (scope.instanceOf === "accordion") {
                console.log(scope);
              }
              define(scope, instance);
            }
          }
        } else {
          define(scope);
        }
      }
    }
    onNextTick(() => [
      mounted2.clear()
    ]);
    $.page.type === 0 && snap.sync(snapshot, $.page.key);
    return promises.length > 0 ? mount(promises) : Promise.resolve();
  };
  var isPender = /\b(?:append|prepend)/;
  var Whitespace = /\s+/g;
  var isBoolean = /^\b(?:true|false)$/i;
  var isNumber = /^\d*\.?\d+$/;
  var isNumeric = /^(?:[.-]?\d*\.?\d+|NaN)$/;
  var isPrefetch = /\b(?:intersect|hover|proximity)\b/;
  var isResourceTag = /\b(?:SCRIPT|STYLE|LINK)\b/;
  var isArray = /\[(['"]?.*['"]?,?)\]/;
  var inPosition = /[xy]\s*|\d*\.?\d+/gi;
  var walkNode = (node, context2, strict = true) => {
    if (strict && !isDirective(node.attributes))
      return;
    node.hasAttribute($.qs.$component) ? setComponent(node, node.getAttribute($.qs.$component), context2) : setAttrs(node, context2, null, null);
  };
  var getComponentValues = (input2, cb) => {
    const names = input2.trim().replace(/\s+/, " ").split(/[|, ]/);
    for (let i2 = 0, n = 0, s2 = names.length; i2 < s2; i2++) {
      if (names[i2] === "")
        continue;
      if ((n = i2 + 2) < s2 && names[i2 + 1] === "as") {
        cb(camelCase(names[i2]), camelCase(names[n]));
        i2 = n;
      } else {
        cb(camelCase(names[i2]), null);
      }
    }
  };
  var getEventParams = (attributes, event) => {
    for (let i2 = 0, s2 = attributes.length; i2 < s2; i2++) {
      const { name, value } = attributes[i2];
      if (!$.qs.$param.test(name) || name.startsWith($.qs.$data) || !value)
        continue;
      const prop = name.slice($.config.schema.length).split(":").pop();
      if (event.params === null)
        event.params = o();
      if (!(prop in event.params))
        event.params[prop] = getAttrValueType(value);
    }
  };
  var isDirective = (attrs) => {
    if (typeof attrs === "string") {
      return attrs.indexOf("@") > -1 || attrs === $.qs.$component || attrs === $.qs.$node || attrs === $.qs.$bind;
    }
    for (let i2 = attrs.length - 1; i2 >= 0; i2--)
      if (isDirective(attrs[i2].name))
        return true;
    return false;
  };
  var isChild = (scope, node) => scope.status === 2 || scope.status === 3 ? scope.root ? scope.root.contains(node) : false : false;
  var getAttrValueNotation = (input2) => {
    return equalizeWS(input2.replace(/\s \./g, ".")).replace(/\s+/g, " ").trim().split(/[ ,]/);
  };
  var getAttrValueType = (input2) => {
    if (isNumeric.test(input2))
      return input2 === "NaN" ? NaN : +input2;
    if (isBoolean.test(input2))
      return input2 === "true";
    const code = input2.charCodeAt(0);
    return code === 123 || code === 91 ? attrJSON(input2) : input2;
  };
  var getContext = ($morph = null, $snapshot = null) => {
    return o({
      $aliases: o(),
      $scopes: o(),
      $element: null,
      $snaps: $morph ? o() : null,
      $morph,
      $snapshot
    });
  };
  var getSelector = (node, attrName, attrValue, contains2) => {
    attrValue || (attrValue = node.getAttribute(attrName));
    return `${node.nodeName.toLowerCase()}[${attrName}${contains2 ? "*=" : "="}"${attrValue}"]`;
  };
  var getScope = (id, { $scopes, $aliases }) => id in $aliases ? last($scopes[$aliases[id]]) : id in $scopes ? last($scopes[id]) : ($scopes[id] = [setScope([id])])[0];
  var defineDomRef = (node, instance, ref, selector2) => {
    $.components.$reference[ref] = instance;
    const value = node.getAttribute($.qs.$ref);
    node.setAttribute($.qs.$ref, value ? `${value},${ref}` : ref);
    selector2 && snap.add(selector2, ref);
    return ref;
  };
  var setScope = ([instanceOf, aliasOf = null], root, context2) => {
    const scope = o();
    scope.key = uuid();
    scope.ref = `c.${scope.key}`;
    scope.status = 5;
    scope.state = o();
    scope.nodes = o();
    scope.binds = o();
    scope.events = o();
    if (root) {
      scope.snap = null;
      scope.status = 2;
      scope.inFragment = contains(root);
      scope.alias = aliasOf || null;
      defineGetter(scope, "root", root, true);
      defineDomRef(root, scope.key, scope.ref, getSelector(root, $.qs.$component));
    }
    if ($.components.$registry.has(instanceOf)) {
      scope.instanceOf = instanceOf;
      if (scope.alias) {
        if (!$.components.$registry.has(scope.alias)) {
          if (scope.alias in context2.$scopes) {
            for (const { events, nodes, binds } of context2.$scopes[scope.alias]) {
              if ("events" in scope) {
                for (const e2 in events) {
                  scope.events[e2] = events[e2];
                  $.components.$reference[e2] = scope.key;
                }
              }
              if ("nodes" in scope) {
                for (const n in nodes) {
                  scope.nodes[n] = nodes[n];
                  $.components.$reference[n] = scope.key;
                }
              }
              if ("binds" in scope) {
                for (const b3 in binds) {
                  scope.binds[b3] = binds[b3];
                  $.components.$reference[b3] = scope.key;
                }
              }
            }
            delete context2.$scopes[scope.alias];
          } else {
            context2.$aliases[scope.alias] = instanceOf;
          }
        } else {
          log(5, [
            `The component alias ("${scope.alias}") matches a component identifer in the registry.`,
            "An alias reference must be unique and cannot match component names."
          ]);
        }
      } else {
        scope.alias = null;
      }
    } else {
      instanceOf ? scope.alias = instanceOf : scope.instanceOf = null;
      if (scope.status === 2) {
        context2.$aliases[scope.alias] = null;
      }
    }
    return scope;
  };
  var setEvent = (node, name, valueRef, context2) => {
    const eventName = name.slice($.config.schema.length);
    const isWindow = eventName.startsWith("window:");
    const hasOptions = valueRef.indexOf("{");
    const values = valueRef.trim().split(hasOptions > -1 ? new RegExp("(?<=[$_\\w}])\\s+(?=[$_\\w])") : /\s+/);
    for (let i2 = 0, s2 = values.length; i2 < s2; i2++) {
      const value = values[i2];
      const listener = new AbortController();
      const ev = o();
      ev.key = `e.${uuid()}`;
      ev.isWindow = isWindow;
      ev.eventName = isWindow ? eventName.slice(7) : eventName;
      ev.attached = false;
      ev.selector = getSelector(node, escSelector(name), value, true);
      ev.params = null;
      ev.options = { signal: listener.signal };
      let attrVal = value;
      if (hasOptions > -1) {
        const args = value.slice(hasOptions, value.lastIndexOf("}", hasOptions)).match(/(passive|once|capture)/g);
        if (args !== null) {
          ev.options.once = args.indexOf("once") > -1;
          ev.options.passive = args.indexOf("passive") > -1;
          ev.options.capture = args.indexOf("capture") > -1;
        }
        attrVal = value.slice(0, hasOptions);
      }
      const [instanceOf, method] = getAttrValueNotation(attrVal)[0].split(".");
      const scope = getScope(instanceOf, context2);
      ev.listener = listener;
      ev.method = method.trim();
      ev.isChild = isChild(scope, node);
      defineGetter(ev, "dom", node, true);
      defineDomRef(node, scope.key, ev.key, ev.selector);
      scope.events[ev.key] = ev;
    }
  };
  var setNodes2 = (node, value, context2) => {
    const nodes = getAttrValueNotation(value);
    for (const nodeValue of nodes) {
      const [instanceOf, name] = nodeValue.split(".");
      const scope = getScope(instanceOf, context2);
      if (name in scope.nodes) {
        scope.nodes[name].live++;
        scope.nodes[name].isWithin = isChild(scope, node);
      } else {
        const selector2 = `[${$.qs.$node}*="${value}"]`;
        const schema = `${name}Node`;
        scope.nodes[name] = o({
          name,
          key: `c.${scope.key}`,
          selector: selector2,
          live: 1,
          isWithin: isChild(scope, node),
          schema: [schema, `${schema}s`, `has${upcase(schema)}`]
        });
      }
    }
  };
  var setBinds = (node, value, context2) => {
    var _a2;
    for (const bindValue of getAttrValueNotation(value)) {
      const [instanceOf, stateKey] = bindValue.split(".");
      const scope = getScope(instanceOf, context2);
      const selector2 = `[${$.qs.$bind}="${value}"]`;
      const key = defineDomRef(node, scope.key, `b.${uuid()}`, `${node.nodeName.toLowerCase()}${selector2}`);
      (_a2 = scope.binds)[stateKey] || (_a2[stateKey] = o());
      scope.binds[stateKey][key] = o({
        key,
        stateKey,
        selector: selector2,
        value: node.innerText,
        dom: context2.$element,
        live: true,
        stateAttr: `${$.config.schema}${instanceOf}:${stateKey}`,
        isChild: isChild(scope, node)
      });
    }
  };
  var setAttrs = (node, context2, instanceOf, alias) => {
    if (instanceOf === null && alias === null) {
      context2.$element = uuid();
    }
    for (let n = node.attributes.length - 1; n >= 0; n--) {
      const { name, value } = node.attributes[n];
      if (instanceOf) {
        let schema = `${$.config.schema}${instanceOf}:`;
        if (alias && !name.startsWith(schema))
          schema = `${$.config.schema}${alias}:`;
        if (name.startsWith(schema)) {
          getScope(instanceOf, context2).state[camelCase(name.slice(schema.length))] = value;
        }
      }
      if (name.indexOf("@") > -1) {
        setEvent(node, name, value, context2);
      } else if (name === $.qs.$bind) {
        setBinds(node, value, context2);
      } else if (name === $.qs.$node) {
        setNodes2(node, value, context2);
      }
    }
  };
  var setComponent = (node, value, context2) => {
    getComponentValues(value, (instanceOf, aliasOf) => {
      if (!$.components.$registry.has(instanceOf)) {
        log(5, `Component does not exist in registry: ${instanceOf}`);
      } else {
        let scope;
        if (instanceOf in context2.$scopes) {
          scope = last(context2.$scopes[instanceOf]);
          if (scope.status === 5) {
            scope.status = 2;
            scope.inFragment = contains(node);
            defineGetter(scope, "root", node, true);
            defineDomRef(node, scope.key, scope.ref, getSelector(node, $.qs.$component));
          } else {
            context2.$scopes[instanceOf].push(setScope([instanceOf, aliasOf], node, context2));
          }
        } else {
          context2.$scopes[instanceOf] = [setScope([instanceOf, aliasOf], node, context2)];
        }
        scope = last(context2.$scopes[instanceOf]);
        if (aliasOf) {
          context2.$aliases[aliasOf] = instanceOf;
        } else if (scope.alias && !(scope.alias in context2.$aliases)) {
          if ($.components.$registry.has(scope.alias)) {
            log(3, `Alias must not match a component identifier: ${scope.instanceOf} as ${scope.alias}`);
            scope.alias = null;
          } else {
            context2.$aliases[scope.alias] = instanceOf;
          }
        }
        setAttrs(node, context2, instanceOf, scope.alias);
      }
    });
  };
  var getComponents = (nodes) => {
    const context2 = getContext();
    if (!nodes) {
      const snapshot = snap.set($.snapDom.body);
      walkElements(b(), (node) => walkNode(node, context2));
      isEmpty(context2.$scopes) || setInstances(context2, snapshot.ownerDocument);
    } else if (nodes instanceof Set) {
      nodes.forEach((node) => walkNode(node, context2));
      nodes.clear();
      return context2;
    } else {
      walkNode(nodes, context2);
      return context2;
    }
  };
  var contains = (node) => {
    for (const [id, fragment] of $.fragments) {
      if (id === node.id)
        return true;
      if (fragment.contains(node))
        return true;
    }
    return false;
  };
  var connect3 = () => {
    $.fragments.clear();
    let selector2;
    let directive;
    let aliases;
    const dom = b();
    if ($.page.target.length > 0) {
      directive = $.qs.$target;
      selector2 = $.page.target.join(",");
      aliases = nodeSet(dom.querySelectorAll(`[id][${$.qs.$component}]`));
    } else {
      directive = $.qs.$fragment;
      selector2 = $.config.fragments.length === 1 && $.config.fragments[0] === "body" ? $.qs.$fragments : `${$.config.fragments.join()},${$.qs.$fragments}`;
    }
    forNode(selector2, (node) => {
      if (aliases) {
        for (const alias of aliases) {
          if (!node.contains(alias))
            continue;
          aliases.delete(alias);
          break;
        }
      }
      if (node.hasAttribute(directive)) {
        const attr = node.getAttribute(directive).trim();
        node.id !== nil && (attr === "true" || attr === nil) ? $.fragments.set(`#${node.id}`, node) : $.fragments.set(getSelector(node, directive, attr), node);
      } else {
        $.fragments.set(`#${node.id}`, node);
      }
    });
    if (aliases && aliases.size > 0) {
      for (const child of aliases) {
        $.fragments.set(`#${child.id}`, child);
        $.page.target.push(`#${child.id}`);
        mark.add(child.id);
      }
      aliases.clear();
    }
    patch("fragments", [...$.fragments.keys()]);
  };
  var setFragmentElements = (page) => {
    if (page.type === 6 || page.selector === "body" || page.selector === null)
      return;
    onNextTick(() => {
      const snapDom = getSnapDom(page.snap);
      const targets2 = snapDom.body.querySelectorAll($.qs.$targets);
      const domNode = b().querySelectorAll($.qs.$targets);
      forNode(targets2, (node, index) => {
        if (contains(node)) {
          log(3, "The fragment or target is a decedent of an element which morphs", node);
        } else {
          if (!node.hasAttribute("id")) {
            node.setAttribute("id", `t.${uuid()}`);
            domNode && domNode[index].setAttribute("id", `t.${uuid()}`);
          } else if (node.id.startsWith("t.")) {
            return;
          }
          page.target.push(node.id);
        }
      });
      setSnap(snapDom.documentElement.outerHTML, page.snap);
    });
  };
  var create = (page) => {
    const has3 = hasProps(page);
    page.ts = ts();
    page.target = targets(page);
    page.selector = selector(page.target);
    if ($.config.cache) {
      has3("cache") || (page.cache = $.config.cache);
      page.snap || (page.snap = uuid());
    }
    if ($.config.hover !== false && page.type === 10) {
      page.threshold || (page.threshold = $.config.hover.threshold);
    }
    if ($.config.proximity !== false && page.type === 12) {
      page.proximity || (page.proximity = $.config.proximity.distance);
      page.threshold || (page.threshold = $.config.proximity.threshold);
    }
    if ($.config.progress) {
      page.progress || (page.progress = $.config.progress.threshold);
    }
    if (!has3("history"))
      page.history = true;
    page.scrollY || (page.scrollY = 0);
    page.scrollX || (page.scrollX = 0);
    page.fragments || (page.fragments = $.config.fragments);
    page.visits || (page.visits = 0);
    page.components || (page.components = []);
    page.location || (page.location = getLocation(page.key));
    $.pages[page.key] = page;
    return $.pages[page.key];
  };
  var newPage = (page) => {
    const state = o(__spreadProps(__spreadValues({}, page), {
      target: [],
      selector: null,
      cache: $.config.cache,
      history: true,
      scrollX: 0,
      scrollY: 0,
      fragments: $.config.fragments
    }));
    if ($.config.hover) {
      state.threshold = $.config.hover.threshold;
    }
    if ($.config.proximity) {
      state.proximity = $.config.proximity.distance;
      state.threshold = $.config.proximity.threshold;
    }
    if ($.config.progress) {
      state.progress = $.config.progress.threshold;
    }
    return state;
  };
  var patch = (prop, value, key = $.history.key) => {
    if (key in $.pages && prop in $.pages[key]) {
      if (prop === "location") {
        $.pages[key][prop] = Object.assign($.pages[prop][key], value);
      } else if (prop === "target") {
        $.pages[key].target = targets(value);
        $.pages[key].selector = selector($.pages[key].target);
      } else {
        $.pages[key][prop] = value;
      }
    }
  };
  var set = (page, snapshot) => {
    const event = emit("before:cache", page, snapshot);
    const dom = typeof event === "string" ? event : snapshot;
    if (page.type > 5) {
      if (page.type > 9) {
        page.type = 1;
      }
    }
    page.title = getTitle(snapshot);
    if (!$.config.cache || event === false)
      return page;
    if (page.type !== 0 && !hasProp(page, "snap"))
      return update(page, dom);
    $.pages[page.key] = page;
    $.snaps[page.snap] = dom;
    setFragmentElements(page);
    emit("after:cache", page);
    return page;
  };
  var update = (page, snapshot = null) => {
    const state = page.key in $.pages ? $.pages[page.key] : create(page);
    if (snapshot) {
      $.snaps[state.snap] = snapshot;
      page.title = getTitle(snapshot);
    }
    return Object.assign(state, page);
  };
  var setSnap = (snapshot, key) => {
    const snap2 = key = key ? key.charCodeAt(0) === 47 ? key in $.pages ? $.pages[key].snap : null : key : null;
    if (snap2) {
      $.snaps[snap2] = snapshot;
    } else {
      delete $.pages[key];
      log(3, "Snapshot record does not exist, update failed");
    }
  };
  var get = (key) => {
    if (!key) {
      if ($.history === null) {
        log(3, "Missing history state reference, page cannot be returned");
        return;
      }
      key = $.history.key;
    }
    if (key in $.pages) {
      return defineGetterProps(o(), [
        ["page", () => $.pages[key]],
        ["dom", () => parse($.snaps[$.pages[key].snap])]
      ]);
    }
    log(5, `No record exists: ${key}`);
  };
  var getSnapDom = (key) => {
    const uuid3 = key ? key.charCodeAt(0) === 47 ? $.pages[key].snap : key : $.page.snap;
    return parse($.snaps[uuid3]);
  };
  var mounted = () => {
    const live = m();
    const { $instances, $mounted } = $.components;
    for (const key of $mounted) {
      if (!$instances.has(key))
        continue;
      const instance = $instances.get(key);
      const { scope } = instance;
      if (scope.status === 2) {
        if (scope.alias !== null) {
          live.has(scope.alias) ? live.get(scope.alias).push(instance) : live.set(scope.alias, [instance]);
        }
        live.has(scope.instanceOf) ? live.get(scope.instanceOf).push(instance) : live.set(scope.instanceOf, [instance]);
      }
    }
    return live;
  };
  var getPage = (key) => {
    if (!key) {
      if ($.history === null) {
        log(3, "Missing history state reference, page cannot be returned");
        return;
      }
      key = $.history.key;
    }
    if (hasProp($.pages, key))
      return $.pages[key];
    log(5, `No page record exists for: ${key}`);
  };
  var has = (key) => hasProp($.pages, key) && hasProp($.pages[key], "snap") && hasProp($.snaps, $.pages[key].snap) && typeof $.snaps[$.pages[key].snap] === "string";
  var clear = (key) => {
    if (!key) {
      empty($.snaps);
      empty($.pages);
    } else if (typeof key === "string") {
      delete $.snaps[$.pages[key].snap];
      delete $.pages[key];
    } else if (Array.isArray(key)) {
      forEach((url) => {
        delete $.snaps[$.pages[url].snap];
        delete $.pages[url];
      }, key);
    }
  };
  var hostname = origin.replace(/(?:https?:)?(?:\/\/(?:www\.)?|(?:www\.))/, nil);
  var getAttributes = (element2, page) => {
    const state = page ? newPage(page) : o();
    const attrs = element2.getAttributeNames();
    for (let i2 = 0, s2 = attrs.length; i2 < s2; i2++) {
      const nodeName = attrs[i2];
      if (nodeName.startsWith($.qs.$data)) {
        if (!hasProp(state, "data"))
          state.data = o();
        const name = camelCase(nodeName.slice($.qs.$data.length));
        const value = element2.getAttribute(nodeName).trim();
        if (isNumeric.test(value)) {
          state.data[name] = value === "NaN" ? NaN : +value;
        } else if (isBoolean.test(value)) {
          state.data[name] = value === "true";
        } else if (value.charCodeAt(0) === 123 || value.charCodeAt(0) === 91) {
          state.data[name] = attrJSON(nodeName, value);
        } else {
          state.data[name] = value;
        }
      } else {
        if (!$.qs.$attrs.test(nodeName))
          continue;
        const nodeValue = element2.getAttribute(nodeName).trim();
        if (nodeName === "href") {
          state.rev = getKey(location);
          if (!page) {
            state.location = getLocation(nodeValue);
            state.key = getKey(state.location);
          }
        } else {
          const name = nodeName.slice(nodeName.lastIndexOf("-") + 1);
          const value = nodeValue.replace(Whitespace, nil).trim();
          if (name === "target") {
            state[name] = value === "true" ? [] : value !== nil ? splitAttrArrayValue(value) : [];
            state.selector = selector(state[name]);
          } else if (isArray.test(value)) {
            const match = value.match(/\[?[^,'"[\]()\s]+\]?/g);
            state[name] = isPender.test(name) ? match.reduce(chunk(2), []) : match;
          } else if (name === "position") {
            if (inPosition.test(value)) {
              const XY = value.match(inPosition);
              state[`scroll${XY[0].toUpperCase()}`] = +XY[1];
              if (XY.length === 4) {
                state[`scroll${XY[2].toUpperCase()}`] = +XY[3];
              }
            } else {
              log(3, `Invalid attribute value on <${nodeName}>, expected: y:number or x:number`, element2);
            }
          } else if (name === "scroll") {
            if (isNumber.test(value)) {
              state.scrollY = +value;
            } else {
              log(3, `Invalid attribute value on <${nodeName}>, expected: number`, element2);
            }
          } else if (isBoolean.test(value) && !isPrefetch.test(nodeName)) {
            state[name] = value === "true";
          } else if (isNumeric.test(value)) {
            state[name] = +value;
          } else {
            if (name === "history" && value !== "push" && value !== "replace") {
              log(5, `Invalid attribute value on <${nodeName}>, expected: false, push or replace`, element2);
            }
            state[name] = value;
          }
        }
      }
    }
    return state;
  };
  var parsePath = (path) => {
    const state = o();
    const size2 = path.length;
    if (size2 === 1 && path.charCodeAt(0) === 47) {
      state.pathname = path;
      state.hash = nil;
      state.search = nil;
      return state;
    }
    const hash = path.indexOf("#");
    if (hash >= 0) {
      state.hash = path.slice(hash);
      path = path.slice(0, hash);
    } else {
      state.hash = nil;
    }
    const params = path.indexOf("?");
    if (params >= 0) {
      state.search = path.slice(params);
      path = path.slice(0, params);
    } else {
      state.search = nil;
    }
    state.pathname = path;
    return state;
  };
  var getPath = (url, protocol) => {
    const path = url.indexOf("/", protocol);
    if (path > protocol) {
      const hash = url.indexOf("#", path);
      return hash < 0 ? url.slice(path) : url.slice(path, hash);
    }
    const param = url.indexOf("?", protocol);
    if (param > protocol) {
      const hash = url.indexOf("#", param);
      return hash < 0 ? url.slice(param) : url.slice(param, hash);
    }
    return url.length - protocol === hostname.length ? "/" : null;
  };
  var parseOrigin = (url) => {
    const path = url.startsWith("www.") ? url.slice(4) : url;
    const name = path.indexOf("/");
    if (name >= 0) {
      const key = path.slice(name);
      if (path.slice(0, name) === hostname)
        return key.length > 0 ? parsePath(key) : parsePath("/");
    } else {
      const char = path.search(/[?#]/);
      if (char >= 0) {
        if (path.slice(0, char) === hostname)
          return parsePath("/" + path.slice(char));
      } else {
        if (path === hostname)
          return parsePath("/");
      }
    }
    return null;
  };
  var hasOrigin = (url) => {
    if (url.startsWith("http:") || url.startsWith("https:"))
      return 1;
    if (url.startsWith("//"))
      return 2;
    if (url.startsWith("www."))
      return 3;
    return 0;
  };
  var validKey = (url) => {
    if (typeof url !== "string" || url.length === 0)
      return false;
    if (url.charCodeAt(0) === 47) {
      if (url.charCodeAt(1) !== 47)
        return true;
      if (url.startsWith("www.", 2))
        return url.startsWith(hostname, 6);
      return url.startsWith(hostname, 2);
    }
    if (url.charCodeAt(0) === 63)
      return true;
    if (url.startsWith("www."))
      return url.startsWith(hostname, 4);
    if (url.startsWith("http")) {
      const start = url.indexOf("/", 4) + 2;
      return url.startsWith("www.", start) ? url.startsWith(hostname, start + 4) : url.startsWith(hostname, start);
    }
    return false;
  };
  var parseKey = (url) => {
    if (url.charCodeAt(0) === 47) {
      return url.charCodeAt(1) !== 47 ? parsePath(url) : parseOrigin(url.slice(2));
    }
    if (url.charCodeAt(0) === 63) {
      return parsePath(location.pathname + url);
    }
    if (url.startsWith("https:") || url.startsWith("http:")) {
      return parseOrigin(url.slice(url.indexOf("/", 4) + 2));
    }
    if (url.startsWith("www."))
      return parseOrigin(url);
    return null;
  };
  var getKey = (link) => {
    if (typeof link === "object")
      return link.pathname + link.search;
    if (link === nil || link === "/")
      return "/";
    const has3 = hasOrigin(link);
    if (has3 === 1) {
      const protocol = link.charCodeAt(4) === 115 ? 8 : 7;
      const www = link.startsWith("www.", protocol) ? protocol + 4 : protocol;
      return link.startsWith(hostname, www) ? getPath(link, www) : null;
    }
    if (has3 === 2) {
      const www = link.startsWith("www.", 2) ? 6 : 2;
      return link.startsWith(hostname, www) ? getPath(link, www) : null;
    }
    if (has3 === 3) {
      return link.startsWith(hostname, 4) ? getPath(link, 4) : null;
    }
    return link.startsWith(hostname, 0) ? getPath(link, 0) : link.charCodeAt(0) === 47 ? link : null;
  };
  var fallback = ({
    pathname,
    search,
    hash
  } = location) => o({
    hostname,
    origin,
    pathname,
    hash,
    search
  });
  var getLocation = (path) => {
    if (path === nil)
      return fallback();
    const state = parseKey(path);
    if (state === null) {
      log(3, `Invalid pathname: ${path}`);
    }
    state.origin = origin;
    state.hostname = hostname;
    return state;
  };
  var getRoute = (link, type = 6) => {
    if (link instanceof Element) {
      const state2 = getAttributes(link);
      state2.type = type || 6;
      return state2;
    }
    const state = o();
    if (link === 0) {
      state.location = fallback();
      state.key = state.rev = getKey(state.location);
      state.type = link;
      state.visits = 1;
      $.index = state.key;
    } else if (type === 7) {
      state.location = getLocation(link);
      state.key = state.rev = getKey(state.location);
      state.type = type;
    } else if (type === 4) {
      state.location = getLocation(link);
      state.key = state.rev = getKey(state.location);
      state.type = type;
    } else {
      state.rev = location.pathname + location.search;
      state.location = getLocation(typeof link === "string" ? link : state.rev);
      state.key = getKey(state.location);
      state.type = type;
    }
    return state;
  };
  var http = (key, {
    method = "GET",
    body = null,
    headers = null,
    type = "text"
  } = {}) => new Promise(function(resolve, reject) {
    const xhr = new XHR();
    xhr.key = key;
    xhr.responseType = type;
    xhr.open(method, key, true);
    xhr.setRequestHeader("spx-request", "true");
    if (headers !== null) {
      for (const prop in headers) {
        xhr.setRequestHeader(prop, headers[prop]);
      }
    }
    xhr.onloadstart = function() {
      XHR.$request.set(this.key, xhr);
    };
    xhr.onload = function() {
      resolve(this.response);
    };
    xhr.onerror = function() {
      reject(this.statusText);
    };
    xhr.onabort = function() {
      delete XHR.$timeout[this.key];
      XHR.$transit.delete(this.key);
      XHR.$request.delete(this.key);
    };
    xhr.onloadend = function(event) {
      XHR.$request.delete(this.key);
      $.memory.bytes = $.memory.bytes + event.loaded;
      $.memory.visits = $.memory.visits + 1;
    };
    xhr.send(body);
  });
  var cleanup = (key) => {
    if (!(key in XHR.$timeout))
      return true;
    clearTimeout(XHR.$timeout[key]);
    return delete XHR.$timeout[key];
  };
  var throttle = (key, callback, delay) => {
    if (key in XHR.$timeout)
      return;
    if (!has(key))
      XHR.$timeout[key] = setTimeout(callback, delay);
  };
  var cancel = (key) => {
    for (const [url, xhr] of XHR.$request) {
      if (key !== url) {
        xhr.abort();
        log(3, `Pending request aborted: ${url}`);
      }
    }
  };
  var preload = (state) => {
    if ($.config.preload !== null) {
      if (Array.isArray($.config.preload)) {
        const promises = $.config.preload.filter((path) => {
          const route2 = getRoute(
            path,
            3
            /* PRELOAD */
          );
          return route2.key !== path ? fetch(create(route2)) : false;
        });
        return Promise.allSettled(promises);
      } else if (typeof $.config.preload === "object") {
        if (hasProp($.config.preload, state.key)) {
          const promises = $.config.preload[state.key].map((path) => fetch(
            create(
              getRoute(
                path,
                3
                /* PRELOAD */
              )
            )
          ));
          return Promise.allSettled(promises);
        }
      }
    }
  };
  var reverse = (state) => __async(void 0, null, function* () {
    if (state.rev === state.key)
      return;
    const page = create(getRoute(
      state.rev,
      4
      /* REVERSE */
    ));
    yield onNextTickResolve();
    fetch(page).then((page2) => {
      if (page2) {
        log(2, `Reverse fetch completed: ${page2.rev}`);
      } else {
        log(3, `Reverse fetch failed: ${state.rev}`);
      }
    });
  });
  var wait = (state) => __async(void 0, null, function* () {
    if (!XHR.$transit.has(state.key))
      return state;
    const snapshot = yield XHR.$transit.get(state.key);
    XHR.$transit.delete(state.key);
    delete XHR.$timeout[state.key];
    return set(state, snapshot);
  });
  var fetch = (state) => __async(void 0, null, function* () {
    if (XHR.$request.has(state.key)) {
      if (state.type !== 7) {
        if (state.type === 4 && XHR.$request.has(state.rev)) {
          XHR.$request.get(state.rev).abort();
          log(3, `Request aborted: ${state.rev}`);
        } else {
          log(3, `Request in transit: ${state.key}`);
        }
        return false;
      }
    }
    if (!emit("fetch", state)) {
      log(3, `Request cancelled via dispatched event: ${state.key}`);
      return false;
    }
    XHR.$transit.set(state.key, http(state.key));
    return wait(state);
  });
  var setBooleanAttribute = (curElement, newElement, name) => {
    if (curElement[name] !== newElement[name]) {
      curElement[name] = newElement[name];
      curElement[name] ? curElement.setAttribute(name, nil) : curElement.removeAttribute(name);
    }
  };
  var morphAttributes = (curNode, newNode) => {
    if (newNode.nodeType === 11 || curNode.nodeType === 11)
      return;
    const newNodeAttrs = newNode.attributes;
    const cRef = curNode.getAttribute($.qs.$ref);
    const nRef = newNode.getAttribute($.qs.$ref);
    let attrDirective = false;
    let attrNode;
    let attrName;
    let attrNamespaceURI;
    let attrValue;
    let fromValue;
    for (let n = newNodeAttrs.length - 1; n >= 0; n--) {
      attrNode = newNodeAttrs[n];
      attrName = attrNode.name;
      attrValue = attrNode.value;
      attrNamespaceURI = attrNode.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attrNode.localName || attrName;
        fromValue = curNode.getAttributeNS(attrNamespaceURI, attrName);
        if (fromValue !== attrValue) {
          if (attrNode.prefix === "xmlns")
            attrName = attrNode.name;
          curNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
        }
      } else {
        fromValue = curNode.getAttribute(attrName);
        if (fromValue !== attrValue) {
          curNode.setAttribute(attrName, attrValue);
          if (!cRef && !nRef && !attrDirective) {
            attrDirective = isDirective(attrName);
          }
        }
      }
    }
    const curNodeAttrs = curNode.attributes;
    for (let o2 = curNodeAttrs.length - 1; o2 >= 0; o2--) {
      if (curNodeAttrs[o2] === void 0)
        continue;
      attrNode = curNodeAttrs[o2];
      attrName = attrNode.name;
      attrValue = attrNode.value;
      attrNamespaceURI = attrNode.namespaceURI;
      if (attrNamespaceURI) {
        attrName = attrNode.localName || attrName;
        if (!newNode.hasAttributeNS(attrNamespaceURI, attrName)) {
          curNode.removeAttributeNS(attrNamespaceURI, attrName);
        }
      } else {
        if (!newNode.hasAttribute(attrName)) {
          curNode.removeAttribute(attrName);
        }
        if (!attrDirective) {
          attrDirective = isDirective(attrName);
        }
      }
    }
    if (cRef || nRef || attrDirective) {
      updateNode(curNode, newNode, cRef, nRef);
    }
  };
  var option = (curElement, newElement) => {
    let parentNode = curElement.parentNode;
    if (parentNode) {
      let parentName = parentNode.nodeName.toUpperCase();
      if (parentName === "OPTGROUP") {
        parentNode = parentNode.parentNode;
        parentName = parentNode && parentNode.nodeName.toUpperCase();
      }
      if (parentName === "SELECT" && !parentNode.hasAttribute("multiple")) {
        if (curElement.hasAttribute("selected") && !newElement.selected) {
          curElement.setAttribute("selected", "selected");
          curElement.removeAttribute("selected");
        }
        parentNode.selectedIndex = -1;
      }
    }
    setBooleanAttribute(curElement, newElement, "selected");
  };
  var input = (curElement, newElement) => {
    setBooleanAttribute(curElement, newElement, "checked");
    setBooleanAttribute(curElement, newElement, "disabled");
    if (curElement.value !== newElement.value)
      curElement.value = newElement.value;
    if (!newElement.hasAttribute("value"))
      curElement.removeAttribute("value");
  };
  var textarea = (curElement, newElement) => {
    const { value } = newElement;
    if (curElement.value !== value)
      curElement.value = value;
    const { firstChild } = curElement;
    if (firstChild) {
      const { nodeValue } = firstChild;
      if (nodeValue === value || !value && nodeValue === curElement.placeholder)
        return;
      firstChild.nodeValue = value;
    }
  };
  var select = (curElement, newElement) => {
    if (!newElement.hasAttribute("multiple")) {
      let i2 = 0;
      let selectedIndex = -1;
      let curChild = curElement.firstElementChild;
      let optgroup;
      let nodeName;
      while (curChild) {
        nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
        if (nodeName === "OPTGROUP") {
          optgroup = curChild;
          curChild = optgroup.firstElementChild;
        } else {
          if (nodeName === "OPTION") {
            if (curChild.hasAttribute("selected")) {
              selectedIndex = i2;
              break;
            }
            i2++;
          }
          curChild = curChild.nextElementSibling;
          if (!curChild && optgroup) {
            curChild = optgroup.nextElementSibling;
            optgroup = null;
          }
        }
      }
      curElement.selectedIndex = selectedIndex;
    }
  };
  var createElementNS = (nodeName, namespaceURI) => !namespaceURI || namespaceURI === "http://www.w3.org/1999/xhtml" ? document.createElement(nodeName) : document.createElementNS(namespaceURI, nodeName);
  var matchName = (curNodeName, newNodeName) => {
    if (curNodeName === newNodeName)
      return true;
    const curCodeStart = curNodeName.charCodeAt(0);
    const newCodeStart = newNodeName.charCodeAt(0);
    return curCodeStart <= 90 && newCodeStart >= 97 ? curNodeName === newNodeName.toUpperCase() : newCodeStart <= 90 && curCodeStart >= 97 ? newNodeName === curNodeName.toUpperCase() : false;
  };
  var formNodes = (curElement, newElement) => {
    switch (curElement.nodeName) {
      case "INPUT":
        input(
          curElement,
          newElement
        );
        break;
      case "OPTION":
        option(
          curElement,
          newElement
        );
        break;
      case "SELECT":
        select(
          curElement,
          newElement
        );
        break;
      case "TEXTAREA":
        textarea(
          curElement,
          newElement
        );
        break;
    }
  };
  var getKey2 = (node) => node ? "getAttribute" in node ? node.getAttribute("id") : void 0 : void 0;
  var moveChildren = (curElement, newElement) => {
    let firstChild = curElement.firstChild;
    let nextChild;
    while (firstChild) {
      nextChild = firstChild.nextSibling;
      newElement.appendChild(firstChild);
      firstChild = nextChild;
    }
    return newElement;
  };
  var removeNode2 = (curNode, parentNode, context2, skipKeys = true) => {
    removeNode(curNode);
    parentNode && parentNode.removeChild(curNode);
    walkNodes(curNode, skipKeys, context2);
  };
  var morphEqual = (curElement) => {
    if (curElement.nodeType === 1) {
      if (curElement.hasAttribute($.qs.$node)) {
        readNode(curElement);
      }
    }
  };
  var morphChildren = (curElement, newElement, context2) => {
    let newNode = newElement.firstChild;
    let newKey;
    let newNextSibling;
    let curNode = curElement.firstChild;
    let curKey;
    let curNodeType;
    let curNextSibling;
    let curMatch;
    outer:
      while (newNode) {
        newKey = getKey2(newNode);
        newNextSibling = newNode.nextSibling;
        while (curNode) {
          curNextSibling = curNode.nextSibling;
          if (newNode.isEqualNode(curNode)) {
            morphEqual(curNode);
            newNode = newNextSibling;
            curNode = curNextSibling;
            continue outer;
          }
          curKey = getKey2(curNode);
          curNodeType = curNode.nodeType;
          let isCompatible;
          if (curNodeType === newNode.nodeType) {
            if (curNodeType === 1) {
              if (newKey) {
                if (newKey !== curKey) {
                  if (curMatch = context2.$lookup.get(newKey)) {
                    if (curNextSibling && curNextSibling.isEqualNode(curMatch)) {
                      isCompatible = false;
                    } else {
                      curElement.insertBefore(
                        curMatch,
                        curNode
                      );
                      if (curKey) {
                        context2.$remove.add(curKey);
                      } else {
                        removeNode2(
                          curNode,
                          curElement,
                          context2
                        );
                      }
                      curNode = curMatch;
                      curKey = getKey2(curNode);
                    }
                  } else {
                    isCompatible = false;
                  }
                }
              } else if (curKey) {
                isCompatible = false;
              }
              isCompatible = isCompatible !== false && matchName(
                curNode.nodeName,
                newNode.nodeName
              );
              if (isCompatible) {
                morphElement(
                  curNode,
                  newNode,
                  context2
                );
              }
            } else if (curNodeType === 3 || curNodeType === 8) {
              isCompatible = true;
              if (curNode.nodeValue !== newNode.nodeValue)
                curNode.nodeValue = newNode.nodeValue;
            }
          }
          if (isCompatible) {
            newNode = newNextSibling;
            curNode = curNextSibling;
            continue outer;
          }
          if (curKey) {
            context2.$remove.add(curKey);
          } else {
            removeNode2(
              curNode,
              curElement,
              context2
            );
          }
          curNode = curNextSibling;
        }
        if (newKey && (curMatch = context2.$lookup.get(newKey)) && matchName(curMatch.nodeName, newNode.nodeName)) {
          curElement.appendChild(curMatch);
          morphElement(curMatch, newNode, context2);
        } else {
          if (newNode.actualize)
            newNode = newNode.actualize(curElement.ownerDocument || document);
          curElement.appendChild(newNode);
          addedNode2(newNode, context2);
        }
        newNode = newNextSibling;
        curNode = curNextSibling;
      }
    cleanNode(
      curElement,
      curNode,
      curKey,
      context2
    );
    formNodes(
      curElement,
      newElement
    );
  };
  var morphElement = (curElement, newElement, context2) => {
    const newKey = getKey2(newElement);
    newKey && context2.$lookup.delete(newKey);
    if (curElement.isEqualNode(newElement))
      return;
    const morphAttr = curElement.getAttribute($.qs.$morph);
    if (morphAttr === "false")
      return;
    morphAttr !== "children" && morphAttributes(curElement, newElement);
    curElement.nodeName === "TEXTAREA" ? textarea(curElement, newElement) : morphChildren(curElement, newElement, context2);
  };
  var walkNodes = (curNode, skipKeys, context2) => {
    if (curNode.nodeType !== 1)
      return;
    let curChild = curNode.firstChild;
    while (curChild) {
      let key;
      if (skipKeys && (key = getKey2(curChild))) {
        context2.$remove.add(key);
      } else {
        removeNode(curChild);
        curChild.firstChild && walkNodes(curChild, skipKeys, context2);
      }
      curChild = curChild.nextSibling;
    }
  };
  var addedNode2 = (curElement, context2) => {
    (curElement.nodeType === 1 || curElement.nodeType === 11) && addedNode(curElement);
    let curChild = curElement.firstChild;
    while (curChild) {
      const nextSibling = curChild.nextSibling;
      const curKey = getKey2(curChild);
      if (curKey) {
        const unmatchElement = context2.$lookup.get(curKey);
        if (unmatchElement && matchName(curChild.nodeName, unmatchElement.nodeName)) {
          curChild.parentNode.replaceChild(unmatchElement, curChild);
          morphElement(unmatchElement, curChild, context2);
        } else {
          addedNode2(curChild, context2);
        }
      } else {
        addedNode2(curChild, context2);
      }
      curChild = nextSibling;
    }
  };
  var cleanNode = (curElement, curNode, curKey, context2) => {
    while (curNode) {
      const curNextSibling = curNode.nextSibling;
      if (curKey = getKey2(curNode)) {
        context2.$remove.add(curKey);
      } else {
        removeNode2(curNode, curElement, context2);
      }
      curNode = curNextSibling;
    }
  };
  var indexNode = (fromNode, context2) => {
    if (fromNode.nodeType === 1 || fromNode.nodeType === 11) {
      let childNode = fromNode.firstChild;
      while (childNode) {
        const key = getKey2(childNode);
        key && context2.$lookup.set(key, childNode);
        indexNode(childNode, context2);
        childNode = childNode.nextSibling;
      }
    }
  };
  var morph = (curNode, snapNode) => {
    let newNode = snapNode.cloneNode(true);
    const context2 = o({ $remove: s(), $lookup: m() });
    newNode.nodeType === 11 && (newNode = newNode.firstElementChild);
    indexNode(curNode, context2);
    let morphedNode = curNode;
    const curNodeType = morphedNode.nodeType;
    const newNodeType = newNode.nodeType;
    if (curNodeType === 1) {
      if (newNodeType === 1) {
        if (!matchName(curNode.nodeName, newNode.nodeName)) {
          removeNode(curNode);
          morphedNode = moveChildren(
            curNode,
            createElementNS(newNode.nodeName, newNode.namespaceURI)
          );
        }
      } else {
        morphedNode = newNode;
      }
    } else if (curNodeType === 3 || curNodeType === 8) {
      if (newNodeType === curNodeType) {
        if (morphedNode.nodeValue !== newNode.nodeValue) {
          morphedNode.nodeValue = newNode.nodeValue;
        }
        return morphedNode;
      } else {
        morphedNode = newNode;
      }
    }
    if (morphedNode.isEqualNode(newNode)) {
      removeNode(curNode);
    } else {
      if (newNode.isEqualNode(morphedNode))
        return morphedNode;
      morphElement(morphedNode, newNode, context2);
      if (context2.$remove.size > 0) {
        for (const key of context2.$remove) {
          if (context2.$lookup.has(key)) {
            const node = context2.$lookup.get(key);
            removeNode2(node, node.parentNode, context2, false);
          }
        }
      }
    }
    if (morphedNode !== curNode && curNode.parentNode) {
      if (morphedNode.actualize)
        morphedNode = morphedNode.actualize(curNode.ownerDocument || document);
      curNode.parentNode.replaceChild(morphedNode, curNode);
    }
    context2.$lookup.clear();
    context2.$remove.clear();
    return morphedNode;
  };
  var getLink = (target, selector2) => {
    if (!(target instanceof Element))
      return false;
    const element2 = target.closest(selector2);
    return element2 && element2.tagName === "A" ? element2 : false;
  };
  var canFetch = (target) => {
    if (target.nodeName !== "A")
      return 2;
    const href = target.getAttribute("href");
    if (!href || !validKey(href))
      return 2;
    const key = getKey(href);
    return key === null ? 2 : has(key) ? 2 : 1;
  };
  var getNodeTargets = (selector2, hrefs) => {
    const targets2 = [];
    forNode(
      selector2,
      (targetNode) => {
        if (targetNode.nodeName !== "A") {
          forNode(
            hrefs,
            (linkNode) => canFetch(linkNode) === 1 ? targets2.push(linkNode) : null
          );
        } else {
          if (targetNode.hasAttribute("href") && validKey(targetNode.href)) {
            const key = getKey(targetNode.href);
            if (getKey(key) !== null && has(key) === false)
              targets2.push(targetNode);
          }
        }
      }
    );
    return targets2;
  };
  var getTargets = (selector2) => {
    const targets2 = [];
    forNode(
      selector2,
      (linkNode) => canFetch(linkNode) === 1 ? targets2.push(linkNode) : null
    );
    return targets2;
  };
  var onEnter = (event) => {
    const target = getLink(event.target, $.qs.$hover);
    if (!target)
      return;
    const route2 = getRoute(
      target,
      10
      /* HOVER */
    );
    if (has(route2.key))
      return;
    if (route2.key in XHR.$timeout)
      return;
    target.addEventListener(`${pointer}leave`, onLeave, { once: true });
    const state = create(route2);
    const delay = state.threshold || $.config.hover.threshold;
    throttle(route2.key, function() {
      if (!emit("prefetch", target, route2))
        return;
      fetch(state).then(function() {
        delete XHR.$timeout[route2.key];
        removeListener(target);
      });
    }, delay);
  };
  var onLeave = (event) => {
    const target = getLink(event.target, $.qs.$hover);
    if (target) {
      cleanup(getKey(target.href));
    }
  };
  var addListener = (target) => target.addEventListener(`${pointer}enter`, onEnter);
  var removeListener = (target) => {
    target.removeEventListener(`${pointer}enter`, onEnter);
    target.removeEventListener(`${pointer}leave`, onLeave);
  };
  var connect4 = () => {
    if (!$.config.hover || $.observe.hover)
      return;
    forEach(addListener, getTargets($.qs.$hover));
    $.observe.hover = true;
  };
  var disconnect3 = () => {
    if (!$.observe.hover)
      return;
    forEach(removeListener, getTargets($.qs.$hover));
    $.observe.hover = false;
  };
  var entries;
  var onIntersect = (entry) => __async(void 0, null, function* () {
    if (entry.isIntersecting) {
      const route2 = getRoute(
        entry.target,
        11
        /* INTERSECT */
      );
      if (!emit("prefetch", entry.target, route2))
        return entries.unobserve(entry.target);
      const response = yield fetch(create(route2));
      if (response) {
        entries.unobserve(entry.target);
      } else {
        log(3, `Prefetch will retry at next intersect for: ${route2.key}`);
        entries.observe(entry.target);
      }
    }
  });
  var connect5 = () => {
    if (!$.config.intersect || $.observe.intersect)
      return;
    if (!entries)
      entries = new IntersectionObserver(forEach(onIntersect), $.config.intersect);
    const observe = forEach((target) => entries.observe(target));
    const targets2 = getNodeTargets($.qs.$intersector, $.qs.$intersect);
    observe(targets2);
    $.observe.intersect = true;
  };
  var disconnect4 = () => {
    if (!$.observe.intersect)
      return;
    entries.disconnect();
    $.observe.intersect = false;
  };
  var nodeOutsideTarget = (node) => {
    const targets2 = b().querySelectorAll(`${$.page.target.join(",")},[${$.qs.$target}]`);
    for (let i2 = 0, s2 = targets2.length; i2 < s2; i2++) {
      if (targets2[i2].contains(node))
        return false;
    }
    return true;
  };
  var resources = new MutationObserver(function([mutation]) {
    if (mutation.type !== "childList")
      return;
    const isAdded = mutation.addedNodes.length;
    if (isAdded || mutation.removedNodes.length > 0) {
      const node = isAdded ? mutation.addedNodes[0] : mutation.removedNodes[0];
      if (node.nodeType !== 1)
        return;
      if ($.eval && isResourceTag.test(node.nodeName)) {
        if (node.parentNode.nodeName === "HEAD") {
          if (isAdded) {
            morphHead("appendChild", node);
          } else {
            morphHead("removeChild", node);
          }
        } else {
          if (nodeOutsideTarget(node) && !$.resources.has(node)) {
            $.resources.add(node);
          } else {
            $.resources.delete(node);
          }
        }
      } else if (node instanceof HTMLElement) {
        if (isAdded && !node.hasAttribute($.qs.$ref)) {
          getComponents(node);
        }
      }
    }
  });
  var connect6 = () => {
    if (!$.observe.mutations)
      return;
    resources.observe(document.head, {
      childList: true
    });
    resources.observe(b(), {
      childList: true,
      subtree: true
    });
    $.observe.mutations = true;
  };
  var disconnect5 = () => {
    if (!$.observe.mutations)
      return;
    resources.takeRecords();
    resources.disconnect();
    for (const node of $.resources) {
      b().removeChild(node);
      $.resources.delete(node);
    }
    $.observe.mutations = false;
  };
  var inRange = ({
    clientX,
    clientY
  }, bounds) => clientX <= bounds.right && clientX >= bounds.left && clientY <= bounds.bottom && clientY >= bounds.top;
  var setBounds = (target) => {
    const rect = target.getBoundingClientRect();
    const attr = target.getAttribute($.qs.$proximity);
    const distance = isNumber.test(attr) ? Number(attr) : $.config.proximity.distance;
    return {
      target,
      top: rect.top - distance,
      bottom: rect.bottom + distance,
      left: rect.left - distance,
      right: rect.right + distance
    };
  };
  var observer = (targets2, wait2 = false) => (event) => {
    if (wait2)
      return;
    wait2 = true;
    const node = targets2.findIndex((node2) => inRange(event, node2));
    if (node === -1) {
      onNextTick(() => wait2 = false, $.config.proximity.throttle);
    } else {
      const { target } = targets2[node];
      if (canFetch(target) === 2) {
        targets2.splice(node, 1);
      } else {
        const page = create(getRoute(
          target,
          12
          /* PROXIMITY */
        ));
        const delay = page.threshold || $.config.proximity.threshold;
        throttle(page.key, () => __async(void 0, null, function* () {
          if (!emit("prefetch", target, page))
            return disconnect6();
          const prefetch2 = yield fetch(page);
          if (prefetch2) {
            targets2.splice(node, 1);
            wait2 = false;
            if (targets2.length === 0) {
              disconnect6();
              log(2, "Proximity observer disconnected");
            }
          }
        }), delay);
      }
    }
  };
  var entries2;
  var connect7 = () => {
    if (!$.config.proximity || $.observe.proximity)
      return;
    const target = getTargets($.qs.$proximity);
    const targets2 = target.map(setBounds);
    if (targets2.length > 0) {
      entries2 = observer(targets2);
      addEventListener(`${pointer}move`, entries2, { passive: true });
      $.observe.proximity = true;
    }
  };
  var disconnect6 = () => {
    if (!$.observe.proximity)
      return;
    removeEventListener(`${pointer}move`, entries2);
    $.observe.proximity = false;
  };
  var morphHead2 = (curHead, newHead) => __async(void 0, null, function* () {
    if (!$.eval || !curHead.children || !newHead.children)
      return;
    const curHeadChildren = curHead.children;
    const newHeadExternal = s();
    const newHeadChildren = newHead.children;
    const newHeadRemovals = [];
    for (let i2 = 0, s2 = newHeadChildren.length; i2 < s2; i2++) {
      if (canEval(newHeadChildren[i2])) {
        newHeadExternal.add(newHeadChildren[i2].outerHTML);
      }
    }
    for (let i2 = 0, s2 = curHeadChildren.length; i2 < s2; i2++) {
      const curHeadChildNode = curHeadChildren[i2];
      const canEvalChildNode = canEval(curHeadChildNode);
      const curHeadOuterHTML = curHeadChildNode.outerHTML;
      if (newHeadExternal.has(curHeadOuterHTML)) {
        canEvalChildNode ? newHeadRemovals.push(curHeadChildNode) : newHeadExternal.delete(curHeadOuterHTML);
      } else if (canEvalChildNode) {
        newHeadRemovals.push(curHeadChildNode);
      }
    }
    const promises = [];
    const range = document.createRange();
    for (const outerHTML of newHeadExternal) {
      const node = range.createContextualFragment(outerHTML).firstChild;
      if (hasProp(node, "href") || hasProp(node, "src")) {
        let resolve;
        const promise = new Promise((_) => resolve = _);
        node.addEventListener("load", () => resolve());
        node.addEventListener("error", (error2) => {
          log(3, `Resource <${node.nodeName.toLowerCase()}> failed:`, error2);
          resolve();
        });
        promises.push(promise);
      }
      curHead.appendChild(node);
      newHeadExternal.delete(outerHTML);
    }
    for (let i2 = 0, s2 = newHeadRemovals.length; i2 < s2; i2++) {
      curHead.removeChild(newHeadRemovals[i2]);
    }
    yield Promise.allSettled(promises);
  });
  var morphDom = (page, snapDom) => {
    const pageDom = b();
    if (page.selector === "body" || page.fragments.length === 0) {
      morph(pageDom, snapDom.body);
    } else {
      const elements2 = page.target.length > 0 ? $.fragments.keys() : page.fragments;
      const components = $.components.$registry.size > 0;
      for (const id of elements2) {
        const domNode = $.fragments.get(id);
        const newNode = snapDom.body.querySelector(id);
        if (!newNode || !domNode)
          continue;
        if (!emit("render", domNode, newNode))
          continue;
        if (mark.has(newNode.id)) {
          newNode.setAttribute($.qs.$ref, domNode.getAttribute($.qs.$ref));
        } else {
          if (domNode.isEqualNode(newNode))
            continue;
          components && snap.set(newNode);
          morph(domNode, newNode);
        }
      }
    }
    context && snap.sync(snapDom, page.key);
    page.type !== 6 && patch(
      "type",
      6
      /* VISIT */
    );
    if (page.location.hash !== nil) {
      const anchor = pageDom.querySelector(page.location.hash);
      anchor && anchor.scrollIntoView();
    }
    scrollTo(page.scrollX, page.scrollY);
  };
  var update2 = (page) => {
    disconnect3();
    disconnect4();
    disconnect6();
    disconnect5();
    disconnect2();
    connect3();
    $.eval === false && (document.title = page.title);
    const snapDom = getSnapDom(page.snap);
    morphHead2(h(), snapDom.head);
    morphDom(page, snapDom);
    progress.done();
    connect4();
    connect5();
    connect7();
    connect2();
    connect6();
    emit("load", page);
    return page;
  };
  var api = window.history;
  var reverse2 = () => api.state !== null && "spx" in api.state && "rev" in api.state.spx && api.state.spx.key !== api.state.spx.rev;
  var has2 = (key) => {
    if (api.state === null)
      return false;
    if (typeof api.state !== "object")
      return false;
    if (!("spx" in api.state))
      return false;
    const match = hasProps(api.state.spx)([
      "key",
      "rev",
      "scrollX",
      "scrollY",
      "title",
      "target"
    ]);
    return typeof key === "string" ? match && api.state.spx.key === key : match;
  };
  var load = () => __async(void 0, null, function* () {
    yield promiseResolve();
    $.loaded = true;
  });
  var initialize = (page) => {
    if (has2(page.key)) {
      Object.assign(page, api.state.spx);
      scrollTo(api.state.spx.scrollX, api.state.spx.scrollY);
    } else {
      replace(page);
    }
    return page;
  };
  var replace = ({
    key,
    rev,
    title,
    scrollX,
    scrollY,
    target
  }) => {
    api.replaceState({
      spx: o({
        key,
        rev,
        scrollX,
        scrollY,
        target,
        title: title || document.title
      })
    }, title, key);
    log(1, `History replaceState: ${key}`);
    return api.state.spx;
  };
  var push = ({ key, rev, title, scrollX, scrollY, target }) => {
    api.pushState({
      spx: o({
        key,
        rev,
        scrollX,
        scrollY,
        target,
        title: title || document.title
      })
    }, title, key);
    log(1, `History pushState: ${key}`);
    return api.state.spx;
  };
  var pop = (event) => __async(void 0, null, function* () {
    if (event.state === null || !("spx" in event.state))
      return;
    const { spx: spx2 } = event.state;
    if (has(spx2.key)) {
      if (!has(spx2.rev) && spx2.rev !== spx2.key) {
        reverse(spx2);
      }
      patch("type", 5, spx2.key);
      const { type, key } = update2($.pages[spx2.key]);
      type === 4 ? log(1, `History popState reverse: ${key}`) : log(1, `History popState session: ${key}`);
    } else {
      log(1, `History popState fetch: ${spx2.key}`);
      spx2.type = 5;
      const page = yield fetch(spx2);
      if (!page)
        return location.assign(spx2.key);
      const key = getKey(location);
      if (page.key === key) {
        log(
          1,
          `History popState fetch Complete: ${spx2.key}`,
          "#2cc9ee"
          /* CYAN */
        );
        page.target = [];
        page.selector = null;
        update2(page);
      } else if (has(key)) {
        update2($.pages[key]);
      } else {
        const data = create(getRoute(
          key,
          5
          /* POPSTATE */
        ));
        const page2 = yield fetch(data);
        if (page2)
          push(page2);
      }
    }
  });
  var connect8 = (page) => {
    if ($.observe.history)
      return;
    addEventListener("popstate", pop, false);
    $.observe.history = true;
    if (typeof page === "object" && page.type === 0) {
      return initialize(page);
    }
    return page;
  };
  var disconnect7 = () => {
    if (!$.observe.history)
      return;
    if (api.scrollRestoration)
      api.scrollRestoration = "auto";
    removeEventListener("popstate", pop, false);
    removeEventListener("load", load, false);
    $.observe.history = false;
  };
  var observers = (options2) => {
    for (const key of ["hover", "intersect", "proximity", "progress"]) {
      if (hasProp(options2, key)) {
        if (options2[key] === false) {
          $.config[key] = false;
        } else if (typeof options2[key] === "object") {
          Object.assign($.config[key], options2[key]);
        }
        delete options2[key];
      }
    }
    return options2;
  };
  var not = (attr, name) => {
    const prefix = `:not([${attr}${name}=false]):not([${attr}link])`;
    switch (name.charCodeAt(0)) {
      case 104:
        return `${prefix}:not([${attr}proximity]):not([${attr}intersect])`;
      case 105:
        return `${prefix}:not([${attr}hover]):not([${attr}proximity])`;
      case 112:
        return `${prefix}:not([${attr}intersect]):not([${attr}hover])`;
    }
  };
  var evaluators = (options2, attr, disable) => {
    if ("eval" in options2) {
      if (options2.eval) {
        if (typeof options2.eval === "object") {
          const e2 = Object.assign($.config.eval, options2.eval);
          $.eval = !(e2.link === false && e2.meta === false && e2.script === false && e2.style === false);
        }
      } else {
        $.eval = false;
      }
    }
    return (tag) => {
      if ($.eval === false || $.config.eval[tag] === false) {
        return `${tag}[${attr}eval]:${disable}`;
      }
      if ($.config.eval[tag] === true) {
        return `${tag}:${disable}`;
      }
      const defaults = tag === "link" ? `${tag}[rel=stylesheet]:${disable}` : tag === "script" ? `${tag}:${disable}:not([${attr}eval=hydrate])` : `${tag}:${disable}`;
      if ($.config.eval[tag] === null)
        return defaults;
      if (Array.isArray($.config.eval[tag])) {
        if ($.config.eval[tag].length > 0) {
          return $.config.eval[tag].map((s2) => `${s2}:${disable}`).join(",");
        } else {
          log(3, `Missing eval ${tag} value, SPX will use defaults`);
          return defaults;
        }
      }
      log(4, `Invalid eval ${tag} value, expected boolean or array`);
    };
  };
  var fragments = (options2) => {
    const elements2 = [];
    if ("fragments" in options2 && Array.isArray(options2.fragments) && options2.fragments.length > 0) {
      for (const fragment of options2.fragments) {
        const charCode = fragment.charCodeAt(0);
        if (charCode === 46 || charCode === 91) {
          log(3, [
            `Invalid fragment selector "${fragment}" provided. Fragments must be id annotated values.`,
            "Use spx-target attributes for additional fragment selections."
          ]);
          continue;
        } else if (charCode === 35) {
          elements2.push(fragment.trim());
        } else {
          elements2.push(`#${fragment.trim()}`);
        }
      }
    } else {
      return ["body"];
    }
    return elements2;
  };
  var configure = (options2 = o()) => {
    if ("logLevel" in options2) {
      $.logLevel = options2.logLevel;
      if ($.logLevel === 1) {
        log(1, "Verbose Logging");
      }
    }
    patchSetAttribute();
    Object.defineProperties($, {
      history: { get: () => typeof api.state === "object" && "spx" in api.state ? api.state.spx : null },
      ready: { get: () => document.readyState === "complete" },
      types: {
        get: () => o({
          INITIAL: 0,
          PREFETCH: 1,
          FETCH: 2,
          PRELOAD: 3,
          REVERSE: 4,
          POPSTATE: 5,
          VISIT: 6,
          HYDRATE: 7,
          CAPTURE: 8,
          RELOAD: 9,
          HOVER: 10,
          INTERSECT: 11,
          PROXIMITY: 12
        })
      }
    });
    if ("components" in options2) {
      registerComponents(options2.components);
      delete options2.components;
    }
    Object.assign($.config, observers(options2));
    const schema = $.config.schema;
    const attr = schema === "spx" ? "spx" : schema.endsWith("-") ? schema : schema === null ? nil : `${schema}-`;
    const href = `:not([${attr}disable]):not([href^=\\#])`;
    const disable = `not([${attr}eval=false])`;
    const evals = evaluators(options2, attr, disable);
    $.config.fragments = fragments(options2);
    $.config.schema = attr;
    $.config.index = null;
    $.memory.bytes = 0;
    $.memory.visits = 0;
    $.memory.limit = $.config.maxCache;
    Object.assign($.qs, {
      $attrs: new RegExp(`^href|${attr}(${"hydrate|append|prepend|target|progress|threshold|scroll|position|proximity|hover|cache|history"})$`, "i"),
      $find: new RegExp(`${attr}(?:node|bind|component)|@[a-z]|[a-z]:[a-z]`, "i"),
      $param: new RegExp(`^${attr}[a-zA-Z0-9-]+:`, "i"),
      $target: `${attr}target`,
      $fragment: `${attr}fragment`,
      $fragments: `[${attr}fragment]`,
      $targets: `[${attr}target]:not(a[spx-target]):not([${attr}target=false])`,
      $morph: `${attr}morph`,
      $eval: `${attr}eval`,
      $intersector: `[${attr}intersect]${not(attr, "intersect")}`,
      $track: `[${attr}track]:not([${attr}track=false])`,
      $component: `${attr}component`,
      $node: `${attr}node`,
      $bind: `${attr}bind`,
      $ref: "data-spx",
      $href: $.config.annotate ? `a[${attr}link]${href}` : `a${href}`,
      $script: evals("script"),
      $style: evals("style"),
      $link: evals("link"),
      $meta: evals("meta"),
      $hydrate: `script[${attr}eval=hydrate]:${disable}`,
      $resource: `link[rel=stylesheet][href*=\\.css]:${disable},script[src*=\\.js]:${disable}`,
      $data: `${attr}data:`,
      $proximity: `a[${attr}proximity]${href}${not(attr, "proximity")}`,
      $intersect: `a${href}${not(attr, "intersect")}`,
      $hover: $.config.hover !== false && $.config.hover.trigger === "href" ? `a${href}${not(attr, "hover")}` : `a[${attr}hover]${href}${not(attr, "hover")}`
    });
    progress.style($.config.progress);
  };
  var linkEvent = (event) => !// @ts-ignore
  (event.target && event.target.isContentEditable || event.defaultPrevented || event.button > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
  var handle = function(event) {
    if (!linkEvent(event))
      return;
    const target = getLink(event.target, $.qs.$href);
    if (!target)
      return;
    const key = getKey(target.href);
    if (key === null)
      return;
    const isRoute = key === $.page.key;
    const move = () => {
      log(3, `Drag occurance, visit cancelled: ${key}`);
      handle.drag = true;
      target.removeEventListener(`${pointer}move`, move);
    };
    target.addEventListener(`${pointer}move`, move, { once: true });
    if (handle.drag === true) {
      handle.drag = false;
      return handle(event);
    }
    target.removeEventListener(`${pointer}move`, move);
    if (!emit("visit", event))
      return;
    const click = (state, subsequent = true) => {
      $.pages[state.key].ts = ts();
      $.pages[state.key].visits = state.visits + 1;
      $.pages[state.key].target = $.pages[state.rev].target = state.target;
      $.pages[state.key].selector = $.pages[state.rev].selector = state.selector;
      $.pages[state.rev].scrollX = window.scrollX;
      $.pages[state.rev].scrollY = window.scrollY;
      if (isRoute) {
        log(2, `Identical pathname, page visit skipped: ${key}`);
      } else {
        replace($.pages[state.rev]);
        if (subsequent) {
          push(state);
          update2(state);
        } else {
          visit(state);
        }
      }
    };
    disconnect3();
    disconnect6();
    disconnect4();
    if (has(key)) {
      const attrs = getAttributes(target, $.pages[key]);
      const page = update(attrs);
      target.onclick = (event2) => {
        event2.preventDefault();
        click(page);
      };
    } else if (XHR.$transit.has(key)) {
      cancel(key);
      log(2, `Request in transit: ${key}`);
      const page = $.pages[key];
      target.onclick = (event2) => {
        event2.preventDefault();
        click(page, false);
      };
    } else {
      cancel();
      cleanup(key);
      const page = create(getRoute(
        target,
        6
        /* VISIT */
      ));
      fetch(page);
      target.onclick = (event2) => {
        event2.preventDefault();
        click(page, false);
      };
    }
  };
  function visit(state) {
    return __async(this, null, function* () {
      if (state.progress)
        progress.start(state.progress);
      try {
        const page = yield wait(state);
        if (page) {
          if (page.history === "replace") {
            replace(page);
          } else {
            push(page);
          }
          update2(page);
        } else {
          location.assign(state.key);
        }
      } catch (e2) {
        location.assign(state.key);
      }
    });
  }
  var navigate = (key, state) => __async(void 0, null, function* () {
    if (state) {
      if (typeof state.cache === "string")
        state.cache === "clear" ? clear() : clear(state.key);
      if (state.progress)
        progress.start(state.progress);
      const page = yield fetch(state);
      if (page) {
        push(page);
        update2(page);
      } else {
        location.assign(state.key);
      }
    } else {
      return visit($.pages[key]);
    }
  });
  var connect9 = () => {
    if ($.observe.hrefs)
      return;
    handle.drag = false;
    if (deviceType === "mouseOnly") {
      addEventListener(`${pointer}down`, handle, false);
    } else if (deviceType === "touchOnly") {
      addEventListener("touchstart", handle, false);
    } else {
      addEventListener(`${pointer}down`, handle, false);
      addEventListener("touchstart", handle, false);
    }
    $.observe.hrefs = true;
  };
  var disconnect8 = () => {
    if (!$.observe.hrefs)
      return;
    if (deviceType === "mouseOnly") {
      removeEventListener(`${pointer}down`, handle, false);
    } else if (deviceType === "touchOnly") {
      removeEventListener("touchstart", handle, false);
    } else {
      removeEventListener(`${pointer}down`, handle, false);
      removeEventListener("touchstart", handle, false);
    }
    $.observe.hrefs = false;
  };
  var initialize2 = () => {
    const route2 = getRoute(
      0
      /* INITIAL */
    );
    const state = connect8(create(route2));
    defineGetterProps($, [
      ["prev", () => $.pages[$.history.rev]],
      ["page", () => $.pages[$.history.key]],
      ["snapDom", () => parse($.snaps[$.page.snap])]
    ]);
    const DOMContentLoaded = () => {
      const page = set(state, takeSnapshot());
      connect9();
      connect3();
      connect4();
      connect5();
      connect7();
      connect2();
      connect6();
      enqueue(
        () => patch(
          "type",
          6
          /* VISIT */
        ),
        () => __async(void 0, null, function* () {
          return yield reverse(page);
        }),
        () => __async(void 0, null, function* () {
          return yield preload(page);
        })
      );
      return page;
    };
    return new Promise((resolve) => {
      document.readyState === "loading" ? addEventListener("DOMContentLoaded", () => resolve(DOMContentLoaded())) : resolve(DOMContentLoaded());
    });
  };
  var disconnect9 = () => {
    disconnect7();
    disconnect8();
    disconnect5();
    disconnect3();
    disconnect4();
    disconnect6();
    if ($.config.components) {
      disconnect2();
      teardown();
      $.components.$registry.clear();
    }
    clear();
    if ($.config.globalThis)
      delete window.spx;
    log(2, "Disconnected");
  };
  function spx(options2 = {}) {
    if (isBrowser === false) {
      return log(5, "Invalid runtime environment: window is undefined.");
    }
    if (!spx.supported) {
      return log(5, "Browser does not support SPX");
    }
    if (!window.location.protocol.startsWith("http")) {
      return log(5, "Invalid protocol, SPX expects HTTPS or HTTP protocol");
    }
    configure(options2);
    if ($.config.globalThis && !("spx" in window)) {
      defineGetter(window, "spx", spx);
    }
    const promise = initialize2();
    return function(callback) {
      return __async(this, null, function* () {
        const state = yield promise;
        if (callback.constructor.name === "AsyncFunction") {
          try {
            yield callback(state);
          } catch (e2) {
            log(3, "Connection Error", e2);
          }
        } else {
          callback(state);
        }
        log(2, "Connection Established");
      });
    };
  }
  spx.Component = Component;
  spx.on = on;
  spx.off = off;
  spx.component = component;
  spx.registed = register;
  spx.component = component;
  spx.capture = capture;
  spx.form = form;
  spx.render = render;
  spx.session = session;
  spx.reload = reload;
  spx.fetch = fetch2;
  spx.clear = clear;
  spx.hydrate = hydrate;
  spx.prefetch = prefetch;
  spx.route = route;
  spx.disconnect = disconnect9;
  spx.register = register;
  spx.supported = supported();
  Object.defineProperties(spx, {
    $: { get: () => $ },
    history: {
      value: o({
        get state() {
          return $.history;
        },
        api,
        push,
        replace,
        has: has2,
        reverse: reverse2
      })
    }
  });
  function supported() {
    return !!(isBrowser && window.history.pushState && window.requestAnimationFrame && window.DOMParser && window.Proxy);
  }
  function component(identifer, callback) {
    const instances = [];
    for (const instance of $.components.$instances.values()) {
      const { scope } = instance;
      if (scope.instanceOf === identifer || scope.alias === identifer) {
        instances.push(instance);
      }
    }
    return callback ? forEach(callback, instances) : instances[0];
  }
  function register(...classes) {
    if (typeof classes[0] === "string") {
      if (classes.length > 2) {
        log(5, [
          `Named component registration expects 2 parameters, recieved ${classes.length}.`,
          'Registry should follow this structure: spx.register("identifer", YourComponent)'
        ], classes);
      }
      registerComponents({ [components_exports[0]]: classes[1] });
    } else {
      for (const component2 of classes) {
        if (Array.isArray(component2)) {
          for (const item of component2) {
            if (typeof item[0] === "string") {
              registerComponents({ [item[0]]: item[1] });
            } else if (typeof item === "function") {
              registerComponents({ [getComponentId(item)]: item }, true);
            }
          }
        } else {
          if (typeof component2 === "function") {
            registerComponents({ [getComponentId(component2)]: component2 }, true);
          } else if (typeof component2 === "object") {
            registerComponents(component2);
          }
        }
      }
    }
    connect2();
  }
  function session() {
    return Object.defineProperties(o(), {
      config: { get: () => $.config },
      snaps: { get: () => $.snaps },
      pages: { get: () => $.pages },
      observers: { get: () => $.observe },
      components: { get: () => $.components },
      fragments: { get: () => $.fragments },
      memory: { get: () => $.memory.size = size($.memory.bytes) }
    });
  }
  function reload() {
    return __async(this, null, function* () {
      $.page.type = 9;
      const page = yield fetch($.page);
      if (page) {
        log(2, "Triggered reload, page was re-cached");
        return update2(page);
      }
      log(3, "Reload failed, triggering refresh (cache will purge)");
      return location.assign($.page.key);
    });
  }
  function fetch2(url) {
    return __async(this, null, function* () {
      const link = getRoute(
        url,
        2
        /* FETCH */
      );
      if (link.location.origin !== origin) {
        log(5, "Cross origin fetches are not allowed");
      }
      const dom = yield http(link.key);
      if (dom)
        return dom;
    });
  }
  function render(url, pushState, fn2) {
    return __async(this, null, function* () {
      const page = $.page;
      const route2 = getRoute(url);
      if (route2.location.origin !== origin)
        log(5, "Cross origin fetches are not allowed");
      const dom = yield http(route2.key, { type: "document" });
      if (!dom)
        log(5, `Fetch failed for: ${route2.key}`, dom);
      yield fn2.call(page, dom);
      if (pushState === "replace") {
        page.title = dom.title;
        const state = update(Object.assign(page, route2), takeSnapshot(dom));
        replace(state);
        return state;
      } else {
        return update2(set(route2, takeSnapshot(dom)));
      }
    });
  }
  function capture(targets2) {
    const page = getPage();
    if (!page)
      return;
    const dom = getSnapDom();
    targets2 = Array.isArray(targets2) ? targets2 : page.target;
    if (targets2.length === 1 && targets2[0] === "body") {
      morph(dom.body, b());
      update(page, takeSnapshot(dom));
      return;
    }
    const selector2 = targets2.join(",");
    const current = b().querySelectorAll(selector2);
    forNode(dom.body.querySelectorAll(selector2), (node, i2) => {
      morph(node, current[i2]);
    });
    update(page, takeSnapshot(dom));
  }
  function prefetch(link) {
    return __async(this, null, function* () {
      const path = getRoute(
        link,
        1
        /* PREFETCH */
      );
      if (has(path.key)) {
        log(3, `Cache already exists for ${path.key}, prefetch skipped`);
        return;
      }
      const prefetch2 = yield fetch(create(path));
      if (prefetch2)
        return prefetch2;
      log(5, `Prefetch failed for ${path.key}`);
    });
  }
  function form(action, options2) {
    return __async(this, null, function* () {
      const body = new FormData();
      for (const key in options2.data) {
        body.append(key, options2.data[key]);
      }
      const submit = yield http(action, {
        method: options2.method,
        body
      });
      return submit;
    });
  }
  function hydrate(link, nodes) {
    return __async(this, null, function* () {
      const route2 = getRoute(
        link,
        7
        /* HYDRATE */
      );
      fetch(route2);
      if (Array.isArray(nodes)) {
        route2.hydrate = [];
        route2.preserve = [];
        for (const node of nodes) {
          if (node.charCodeAt(0) === 33) {
            route2.preserve.push(node.slice(1));
          } else {
            route2.hydrate.push(node);
          }
        }
      } else {
        route2.hydrate = $.config.fragments;
      }
      const page = yield wait(route2);
      if (page) {
        const { key } = $.history;
        replace(page);
        update2(page);
        if (route2.key !== key) {
          if ($.index === key)
            $.index = route2.key;
          for (const p22 in $.pages) {
            if ($.pages[p22].rev === key) {
              $.pages[p22].rev = route2.key;
            }
          }
          clear(key);
        }
      }
      return getSnapDom(page.key);
    });
  }
  function route(uri, options2) {
    return __async(this, null, function* () {
      const goto = getRoute(uri);
      const merge = typeof options2 === "object" ? Object.assign(goto, options2) : goto;
      return has(goto.key) ? navigate(goto.key, update(merge)) : navigate(goto.key, create(merge));
    });
  }

  // ../dist/index.js
  var h2 = /* @__PURE__ */ new Map();
  var g = (e2, t = /* @__PURE__ */ Object.create(null)) => e2 ? Object.assign(t, e2) : t;
  var $2 = class extends Array {
    constructor() {
      super(...arguments);
      this.ref = g();
      this.get = (i2) => {
        let s2 = typeof i2;
        if (s2 === "number")
          return this[i2];
        if (s2 === "string") {
          if (i2 in this.ref)
            return this[this.ref[i2]];
          console.error(`Relapse: Unknown fold id: ${i2}`);
        }
        return this;
      };
    }
  };
  var S = (e2, t) => e2.style.getPropertyValue(t) !== "";
  var p2 = (e2, t, i2) => e2.style.setProperty(t, i2);
  var x = (e2, t) => e2.classList.add(t);
  var R = (e2, t) => e2.classList.remove(t);
  var T = (e2, t = 1) => {
    e2.ariaExpanded = t === 1 ? "true" : "false";
  };
  var L = (e2, t = 1) => {
    let i2 = t === 1 ? "true" : "false";
    e2.tagName === "BUTTON" ? (e2.hasAttribute("aria-disabled") && e2.removeAttribute("aria-disabled"), t === 1 ? e2.setAttribute("disabled", i2) : e2.hasAttribute("disabled") && e2.removeAttribute("disabled")) : e2.ariaDisabled = i2;
  };
  var P = (e2) => {
    let t = g();
    return t.on = (i2, s2, r) => (e2[i2] || (e2[i2] = []), e2[i2].push(r ? s2.bind(r) : s2) - 1), t.off = (i2, s2) => {
      let r = e2[i2], u2 = `Relapse: Removed ${i2} event listener`;
      if (r && typeof s2 == "number")
        r.splice(s2, 1), console.warn(`${u2} (id: ${s2})`), r.length === 0 && delete r[i2];
      else {
        let a2 = [];
        if (r && typeof s2 == "function")
          for (let f2 = 0, b2 = r.length; f2 < b2; f2++)
            r[f2] !== s2 ? a2.push(r[f2]) : console.warn(`${u2} (id: ${f2})`);
        a2.length > 0 ? r[i2] = a2 : delete r[i2];
      }
    }, t.emit = (i2, s2, r) => {
      let u2 = e2[i2] || [], a2 = null;
      for (let f2 = 0, b2 = u2.length; f2 < b2; f2++) {
        let E = u2[f2].call(s2, r);
        a2 === null && E === false && (a2 = true);
      }
      return a2;
    }, t;
  };
  var N = (e2) => e2.folds.filter(({ expanded: t }) => t).length;
  var D = (e2, t, i2, s2 = true) => {
    let r = t.button, u2 = t.wrapper;
    p2(u2, "overflow", "hidden"), e2.semantic ? (t.height = r.offsetHeight, s2 && p2(u2, "will-change", "height")) : (t.height = 0, s2 && p2(u2, "will-change", "max-height"));
    let a2 = `${t.height}px`;
    return [a2, u2, () => {
      e2.semantic ? (p2(u2, "height", a2), u2.removeAttribute("open")) : p2(t.element, "max-height", "0"), t.expanded = false, T(r, 2), R(r, e2.options.classes.opened), R(u2, e2.options.classes.expanded), u2.style.removeProperty("will-change"), e2.opened = N(e2), e2.status = 1, i2.emit("collapse", e2, focus);
    }];
  };
  var C = (e2, t, i2) => {
    let s2 = t.options.classes, r = t.options.fade, u2 = g({ easing: r.easing, duration: r.duration * 2 }), a2 = (l2) => {
      if (typeof l2 != "number")
        return t.active !== e2.index && (t.active = e2.index), e2;
      if (!t.folds.get(l2))
        throw new Error(`Relapse: No fold exists using id: "${l2}"`);
      return t.active = e2.index, t.folds.get(l2);
    }, f2 = (l2, n, c) => {
      p2(l2, "will-change", "opacity,visibility");
      let o2 = l2.animate({ opacity: n, visibility: c }, n[0] === "1" ? u2 : r);
      o2.onfinish = () => {
        p2(l2, "opacity", n[1]), p2(l2, "visibility", c[1]), l2.style.removeProperty("will-change");
      };
    }, b2 = (l2, n, c) => {
      t.status = 2;
      let o2 = l2.animate(t.semantic ? { height: n } : { maxHeight: n }, t.options.fold);
      o2.onfinish = c;
    }, E = (l2) => {
      if (l2.disabled)
        return;
      let [n, c, o2] = D(t, l2, i2);
      f2(l2.element, ["1", "0"], ["visible", "hidden"]), b2(c, [`${c.offsetHeight}px`, n], o2);
    }, m2 = (l2) => (n) => {
      l2.close();
      let c = l2.button, o2 = l2.wrapper, d2 = l2.element;
      T(c);
      let y;
      t.semantic ? (o2.setAttribute("open", ""), p2(o2, "will-change", "height"), p2(o2, "overflow", "hidden"), l2.height = c.offsetHeight + d2.offsetHeight, y = `${c.offsetHeight}px`) : (p2(o2, "will-change", "max-height"), l2.height = d2.scrollHeight, y = "0px"), x(c, s2.opened), f2(d2, ["0", "1"], ["hidden", "visible"]), b2(o2, [y, `${l2.height}px`], () => {
        t.semantic ? p2(o2, "height", "auto") : p2(o2, "max-height", "inherit"), o2.style.removeProperty("overflow"), o2.style.removeProperty("will-change"), x(d2, s2.expanded), l2.expanded = true, t.opened = N(t), t.status = 1, t.options.persist && t.opened > 1 && l2.disable(), i2.emit("expand", t, l2);
      });
    };
    e2.close = (l2) => {
      let n = a2(l2);
      if (t.options.multiple)
        t.options.persist === true && t.opened > 1 ? n.expanded === true && E(n) : t.options.persist === false && n.expanded === true && E(n);
      else
        for (let c of t.folds)
          if (c.expanded && c.locked === false) {
            if (t.options.persist && c.index === n.index)
              break;
            E(c), n = c;
            break;
          }
      n.enable(), t.opened = N(t);
    }, e2.focus = () => {
      t.active = e2.index, e2.button.focus({ preventScroll: true }), i2.emit("focus", t, e2);
    }, e2.enable = (l2) => {
      let n = a2(l2);
      n.disabled && !n.locked && (n.disabled = false, L(n.button, 2), R(n.button, s2.disabled));
    }, e2.disable = (l2) => {
      let n = a2(l2);
      n.disabled || (n.expanded ? t.options.persist && (n.disabled = true, L(n.button)) : (n.close(), n.disabled = true, L(n.button), x(n.button, s2.disabled)));
    }, e2.open = (l2) => {
      let n = a2(l2);
      t.status === 2 || n.expanded || requestAnimationFrame(m2(n));
    }, e2.toggle = (l2) => {
      if (t.semantic && l2.preventDefault(), !(t.status === 2 || i2.emit("toggle", t, e2) === false))
        return e2.expanded ? e2.close() : e2.open();
    }, e2.destroy = () => {
      e2.button.removeEventListener("click", e2.toggle), e2.button.removeEventListener("focus", e2.focus), e2.button.removeEventListener("blur", e2.blur);
    }, e2.button.addEventListener("click", e2.toggle), e2.button.addEventListener("focus", e2.focus), t.folds.push(e2), t.folds.ref[e2.element.id] = t.folds.length - 1;
  };
  var I = (e2) => typeof e2 == "object" && "schema" in e2 ? e2.schema : "[data-relapse]";
  var k = (e2) => {
    let t = g({ persist: false, unique: false, multiple: false, schema: "data-relapse", fold: g({ duration: 200, easing: "ease-in-out" }), fade: g({ duration: 120, easing: "linear" }), classes: g({ opened: "opened", disabled: "disabled", expanded: "expanded" }) });
    if (typeof e2 == "object") {
      for (let i2 in e2)
        if (i2 === "classes" || i2 === "fade" || i2 === "fold")
          for (let s2 in e2[i2])
            t[i2][s2] = e2[i2][s2];
        else
          t[i2] = e2[i2];
      "fade" in e2 && "duration" in e2.fade && e2.fade.duration !== t.fade.duration || t.fold.duration !== 200 && (t.fade.duration = t.fold.duration - t.fold.duration / 2.5);
    }
    return t;
  };
  var U = (e2, t) => {
    let i2 = e2.schema.length + 1, s2 = g({ fold: g(), fade: g(), classes: g() });
    for (let { nodeName: r, nodeValue: u2 } of t) {
      if (!r.startsWith(e2.schema))
        continue;
      let a2 = r.slice(i2);
      if (a2 === "schema") {
        console.warn('Relapse: The "schema" option cannot be defined via attribute');
        continue;
      }
      let f2 = u2.trim(), b2 = `Invalid ${r} attribute value.`;
      if (a2 === "persist" || a2 === "multiple" || a2 === "unique")
        if (f2 === "true" || f2 === "false")
          s2[a2] = f2 === "true";
        else
          throw new TypeError(`Relapse: ${b2}. Boolean expected, received: ${f2}`);
      else if (a2 === "fold-duration" || a2 === "fade-duration") {
        if (isNaN(+f2))
          throw new TypeError(`Relapse: ${b2}. Number expected, received: ${f2}`);
        {
          let [E, m2] = a2.split("-");
          s2[E][m2] = +f2;
        }
      } else if (a2.startsWith("class-") || a2 === "fold-easing" || a2 === "fade-easing") {
        let [E, m2] = a2.split("-");
        s2[E][m2] = f2;
      }
    }
    !("fade" in s2 && "duration" in s2.fade && s2.fade.duration !== e2.fade.duration) && "fold" in s2 && "duration" in s2.fold && s2.fold.duration !== e2.fold.duration && (s2.fade.duration = s2.fold.duration - s2.fold.duration / 2.5);
    for (let r in s2)
      if (r === "fold" || r === "classes" || r === "fade")
        for (let u2 in s2[r])
          e2[r][u2] = s2[r][u2];
      else
        e2[r] = s2[r];
    return e2;
  };
  var M = (e2, t) => {
    if (e2 === null)
      return;
    let i2 = e2, s2 = i2.getAttribute(t.schema);
    if ((s2 === null || s2 === "") && (s2 = i2.hasAttribute("id") ? i2.id : `R${h2.size}`, i2.setAttribute(t.schema, s2)), h2.has(s2)) {
      if (h2.get(s2).options.unique === false)
        return;
      throw new Error(`Relapse: Instance already exists with id: ${s2} `);
    }
    let r = U(t, i2.attributes), u2 = new $2(), a2 = h2.set(s2, { id: s2, semantic: i2.firstElementChild.nodeName === "DETAILS", opened: 0, status: 1, active: NaN, events: g(), get options() {
      return r;
    }, get folds() {
      return u2;
    }, get element() {
      return i2;
    }, set element(n) {
      i2 = n, s2 = i2.getAttribute(t.schema);
    } }).get(s2), f2 = P(a2.events), b2 = i2.children.length, E = a2.semantic ? 1 : 2, m2 = a2.options.classes, l2 = 0;
    do {
      let n = g({ index: a2.folds.length, locked: false }), c = false, o2, d2, y, A = a2.semantic;
      if (A) {
        if (y = i2.children[l2], y.nodeName !== "DETAILS")
          throw new Error(`Relapse: Invalid markup on "${a2.id}", expected: <details>`);
        o2 = y.firstElementChild, d2 = o2.nextElementSibling, c = y.hasAttribute("open");
      } else
        o2 = i2.children[l2], d2 = y = i2.children[l2 + 1], d2.hasAttribute("hidden") && d2.removeAttribute("hidden"), d2.firstElementChild.hasAttribute("hidden") && d2.firstElementChild.removeAttribute("hidden");
      let H = o2.classList.contains(m2.opened), O = d2.classList.contains(m2.expanded), w2 = o2.classList.contains(m2.disabled);
      o2.ariaExpanded === "true" || c || H ? (!H && !w2 && x(o2, m2.opened), !O && x(d2, m2.expanded), A || (o2.ariaExpanded !== "true" && T(o2), o2.ariaDisabled === "true" && (L(o2), w2 = true)), w2 && (x(o2, m2.disabled), n.disabled = true, n.locked = true), n.expanded = true) : o2.ariaDisabled === "true" || w2 ? (!w2 && x(o2, m2.disabled), H && R(o2, m2.opened), n.expanded = (O || c) === true, n.disabled = true, n.locked = true, A || (o2.ariaDisabled !== "true" && L(o2), T(o2, n.expanded ? 1 : 2))) : (n.expanded = false, n.disabled = false, A || (T(o2, 2), L(o2, 2))), n.id = `${a2.id}F${n.index}`, o2.hasAttribute("id") || (o2.id = `${a2.id}B${n.index}`), d2.hasAttribute("id") || (d2.id = `${a2.id}C${n.index}`), o2.setAttribute("aria-controls", d2.id), d2.setAttribute("aria-labelledby", o2.id), n.expanded ? (o2.tabIndex = -1, a2.opened = a2.opened + 1, a2.options.multiple === false && a2.opened === 2 && console.warn(`Relapse: More than 1 fold is expanded but "multiple" is set to false on: ${a2.id}`), A ? n.height = o2.offsetHeight + d2.offsetHeight : n.height = d2.scrollHeight) : (o2.tabIndex = 0, A ? n.height = o2.offsetHeight : (n.height = 0, !S(d2, "max-height") && p2(d2, "max-height", "0"), !S(d2, "overflow") && p2(d2, "overflow", "hidden"))), n.button = o2, n.wrapper = y, n.element = d2, C(n, a2, f2), l2 = l2 + E;
    } while (l2 < b2);
    a2.on = f2.on, a2.off = f2.off, a2.config = (n) => {
      let c = r.persist, o2 = r.multiple;
      for (let d2 in n)
        d2 === "unique" || d2 === "schema" || d2 === "classes" || (typeof r[d2] == "object" ? Object.assign(r[d2], n[d2]) : r[d2] !== n[d2] && (r[d2] = n[d2]));
      if (!c && r.persist && a2.opened === 0 && a2.expand(isNaN(a2.active) ? 0 : a2.active), o2 && !r.multiple && a2.opened > 0)
        for (let d2 of a2.folds)
          !d2.expanded || d2.locked || r.persist && a2.active !== d2.index || (f2.emit("toggle", a2, d2), D(a2, d2, f2, false)[2]());
      return r;
    }, a2.collapse = (n = a2.active) => isNaN(n) ? null : u2.get(n).close(n), a2.expand = (n = a2.active) => isNaN(n) ? null : u2.get(n).open(n), a2.destroy = () => {
      u2.forEach((n) => n.destroy()), f2.emit("destroy", a2), h2.delete(s2);
    }, a2.reinit = () => {
      u2.forEach((n) => n.destroy()), M(e2, t);
    };
  };
  var v = function e(t, i2) {
    if (document.readyState === "loading")
      return addEventListener("DOMContentLoaded", () => e(t, i2));
    let s2 = typeof t == "object" && "tagName" in t;
    if (s2 && t instanceof NodeList)
      throw TypeError("Relapse: Invalid NodeList selector. Provide string or HTMLElement");
    if (s2) {
      let u2 = typeof t == "string" ? document.body.querySelector(t) : t;
      u2 !== null && M(u2, k(i2));
    } else
      document.body.querySelectorAll(I(t)).forEach((u2) => M(u2, k(t)));
    let r = Array.from(h2.values());
    return s2 ? r[r.length - 1] : r;
  };
  var F = (e2) => typeof e2 == "string" ? h2.has(e2) ? h2.get(e2) : null : Array.isArray(e2) ? e2.filter((t) => h2.has(t)).map((t) => h2.get(t)) : h2.size > 0 ? Array.from(h2.values()) : null;
  v.version = "0.9.0";
  v.get = F;
  v.each = (e2) => {
    for (let [t, i2] of h2)
      if (e2(i2, t) === false)
        break;
  };
  v.reinit = (e2) => {
    let t = F(e2);
    if (t === null)
      return;
    let i2 = Array.isArray(t) ? t : [t];
    for (let s2 of i2)
      if (typeof s2 == "object" && "id" in s2) {
        let { id: r, options: u2 } = s2;
        s2.destroy(), v(`#${r}`, u2);
      }
  };
  v.has = (e2) => e2 ? (Array.isArray(e2) ? e2 : [e2]).every(h2.has) : h2.size > 0;
  v.destroy = (e2) => {
    let t = F(e2), i2 = Array.isArray(t) ? t : [t];
    for (let s2 of i2)
      s2.destroy();
  };
  window.relapse || Object.defineProperty(window, "relapse", { get() {
    return v;
  } });
  var j = v;

  // node_modules/.pnpm/qvp@0.3.2/node_modules/qvp/index.js
  var i = function(t) {
    if (Array.isArray(t))
      return t.forEach(i);
    if (!("id" in t)) {
      for (let s2 of ["onenter", "onexit", "oninit", "onresize"])
        if (s2 in t)
          throw new Error('qvp: Missing an "id" reference');
      return Object.entries(t).forEach(([s2, o2]) => {
        let c = typeof t[s2];
        if (c === "string")
          return i({ id: s2, query: o2 });
        throw new TypeError(`qvp: Invalid query type. Expected "string" received "${c}"`);
      });
    }
    let n = g2(t), { id: r } = n.screen;
    i.viewports.size || addEventListener("resize", u(() => {
      i.viewports.forEach((s2) => {
        s2.screen.active && s2.onresize(window.innerWidth);
      });
    }, 25), true), i.viewports.has(r) ? console.warn(`qvp: The id "${r}" is already defined, use qvp.add() instead.`) : i.viewports.set(r, n);
  };
  i.viewports = /* @__PURE__ */ new Map();
  Object.defineProperty(i, "isTouch", { get() {
    return "ontouchstart" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
  } });
  i.get = (e2) => i.viewports.has(e2) ? i.viewports.get(e2) : false;
  i.add = (e2, t) => {
    let n = i.get(e2);
    if (n === false)
      return console.error(`qvp: There is no viewport using an id of "${e2}"`);
    f(t, n.screen), n.screen.test.matches && n.onenter();
  };
  i.off = (e2, t) => {
    let n = i.get(e2.split(":")[0]);
    if (n === false || !(e2 in n.events))
      return;
    let r = n.events[e2].length;
    if (typeof t == "number")
      t <= r - 1 && n.events[e2].splice(t, 1);
    else if (typeof t == "function") {
      let s2 = [];
      for (let o2 = 0; o2 < r; o2++)
        n.events[e2][o2] !== t && s2.push(n.events[e2][o2]);
      s2.length > 0 && (n.events[e2] = s2);
    } else
      delete n.events[e2];
  };
  i.on = (e2, t, n) => {
    let [r, s2] = e2.split(":"), o2 = i.get(r);
    if (o2 === false)
      return;
    e2 in o2.events || (o2.events[e2] = []);
    let c = n ? t.bind(n) : t;
    return c["qvp:event"] = o2.events[e2].length, o2.events[e2].push(c), o2.screen.test.matches ? s2 === "oninit" ? c.call() : (s2 === "onenter" && c.call(), f({ [s2]: c }, o2.screen)) : f({ [s2]: c }, o2.screen), c["qvp:event"];
  };
  i.list = (e2) => {
    let t = Array.from(i.viewports.values()).map(({ screen: n }) => n);
    return e2 ? t.filter(({ id: n }) => e2.includes(n)) : t;
  };
  i.active = (e2) => {
    let t = i.list();
    if (e2) {
      let r = i.get(e2);
      return r ? r.screen.active : false;
    }
    let n = t.filter(({ active: r }) => r === true);
    return n.length > 1 ? n : n[0];
  };
  i.test = (e2, t = ",") => typeof e2 == "string" ? e2.indexOf(t) > -1 ? e2.split(t).some(i.active) : !!i.active(e2) : e2.some(i.active);
  i.remove = (e2) => {
    i.viewports.has(e2) && (i.viewports.get(e2).destroy(), i.viewports.delete(e2));
  };
  i.destroy = () => {
    removeEventListener("resize", u()), i.viewports.forEach((e2) => e2.destroy()), i.viewports.clear();
  };
  i.screens = () => {
    throw Error("qvp: The qvp.screens() is deprecated, use the default import, e.g: qvp(...)");
  };
  function u(e2, t) {
    let n = t;
    return function() {
      let r = () => {
        n = null, e2.apply(this, arguments);
      };
      n && cancelAnimationFrame(n), n = requestAnimationFrame(r);
    };
  }
  function f(e2, t) {
    typeof e2.onenter == "function" && ("qvp:event" in e2.onenter || (e2.onenter["qvp:event"] = NaN), t.onenter.add(e2.onenter)), typeof e2.onexit == "function" && ("qvp:event" in e2.onexit || (e2.onexit["qvp:event"] = NaN), t.onexit.add(e2.onexit)), typeof e2.onresize == "function" && ("qvp:event" in e2.onresize || (e2.onresize["qvp:event"] = NaN), t.onresize.add(e2.onresize)), typeof e2.oninit == "function" && ("qvp:event" in e2.oninit || (e2.oninit["qvp:event"] = NaN), t.oninit.add(e2.oninit));
  }
  function a(e2, ...t) {
    let n = i.get(e2.split(":")[0]);
    if (n !== false && e2 in n.events)
      for (let r = 0; r < n.events[e2].length && (n.events[e2][r].apply(null, t), e2.endsWith(":oninit") && i.off(e2, r), e2 in n.events); r++)
        ;
  }
  function g2(e2) {
    let t = e2.query || "all", n = { id: e2.id, query: t, active: false, test: matchMedia(t), onenter: /* @__PURE__ */ new Set(), onexit: /* @__PURE__ */ new Set(), onresize: /* @__PURE__ */ new Set(), oninit: /* @__PURE__ */ new Set(), events: /* @__PURE__ */ Object.create(null) };
    f(e2, n);
    let r = () => {
      n.oninit.size > 0 && (n.oninit.forEach((v2) => !isNaN(v2["qvp:event"]) || v2()), a(`${e2.id}:oninit`), n.oninit.clear()), n.onenter.forEach((v2) => !isNaN(v2["qvp:event"]) || v2()), a(`${e2.id}:onenter`), n.active = true;
    }, s2 = () => {
      n.onexit.forEach((v2) => !isNaN(v2["qvp:event"]) || v2()), a(`${e2.id}:onexit`), n.active = false;
    }, o2 = (v2) => {
      n.onresize.forEach((d2) => !isNaN(d2["qvp:event"]) || d2()), a(`${e2.id}:onresize`, v2);
    }, c = ({ matches: v2 }) => v2 ? r() : s2(), p3 = () => {
      for (let v2 in n.events)
        delete n.events[v2];
      n.test.removeEventListener("change", c);
    };
    return n.test.addEventListener("change", c), n.test.matches && r(), { onenter: r, onexit: s2, onresize: o2, destroy: p3, get screen() {
      return n;
    }, get events() {
      return n.events;
    } };
  }
  var l = i;

  // src/app/components/drawer.ts
  var _Drawer = class _Drawer extends spx.Component {
    constructor() {
      super(...arguments);
      this.transition = (event) => {
        if (event.propertyName !== "transform")
          return;
        if (this.state.hasShift) {
          for (const shift of this.shifts) {
            if (shift.classList.contains(this.shiftClass)) {
              shift.classList.remove(this.shiftClass);
              shift.style.removeProperty("transform");
            }
          }
        }
        if (this.backdrop.classList.contains("backdrop")) {
          this.backdrop.classList.remove("backdrop");
        }
        if (this.state.mode === "pull") {
          this.shifts.item(0).removeEventListener(event.type, this.transition);
        } else {
          this.target.removeEventListener(event.type, this.transition);
        }
      };
      /**
       * Click detected outside, eg: document body
       */
      this.outsideClick = (event) => {
        if (event.target !== this.target) {
          this.close();
          this.html.removeEventListener("click", this.outsideClick, false);
        }
      };
      /**
       * Toggle Drawer
       */
      this.toggle = (event) => {
        if (event)
          event.preventDefault();
        this.state.isOpen = !this.state.isOpen;
        if (this.state.isOpen) {
          this.open();
        } else {
          this.close();
        }
        return this.state.isOpen ? this.open() : this.close();
      };
      /**
       * Touch Move prevention event
       */
      this.touchMove = (event) => {
        if (this.state.isOpen) {
          if (this.target.scrollHeight <= this.target.clientHeight) {
            event.preventDefault();
          }
        }
      };
      /**
       * Keyboard events
       */
      this.keyboard = (event) => {
        switch (event.code) {
          case "Esc":
          case "Escape":
            this.close();
            break;
        }
      };
    }
    /**
     * Returns the backdrop element
     */
    get backdrop() {
      return _Drawer.backdrop;
    }
    /**
     * Returns the drawer direction class name
     */
    get directionClass() {
      return `drawer-${this.state.direction}`;
    }
    /**
     * Returns the drawer shift class name
     */
    get shiftClass() {
      return `drawer-${this.state.mode}`;
    }
    /**
     * Returns the shifts transition class name
     */
    get shifts() {
      return this.html.querySelectorAll(this.state.shift);
    }
    /**
     * Returns all button toggles in the dom
     */
    get buttons() {
      return this.html.querySelectorAll(`[data-drawer="${this.target.id}"]`);
    }
    /**
     * Stimulus: Initialize
     */
    connect() {
      if (!_Drawer.backdrop) {
        _Drawer.backdrop = document.createElement("div");
        _Drawer.backdrop.className = "drawer-backdrop";
        _Drawer.backdrop.setAttribute("spx-morph", "false");
      }
      if (this.state.useParent) {
        this.target = this.root.parentElement;
        this.target.ariaHidden = "true";
      } else {
        this.target = this.root;
      }
      if (this.target.classList.contains("d-none")) {
        this.target.classList.remove("d-none");
      }
      if (this.state.mode !== "overlay" && this.state.hasShift === false) {
        console.error('Missing "data-drawer-shift-value" defintions on:', this.target);
      }
      if (this.html.contains(_Drawer.backdrop) === false) {
        this.html.appendChild(_Drawer.backdrop);
      }
      if (this.state.hasWidth) ;
      if (this.state.hasHeight) {
        this.target.style.setProperty("height", this.state.height);
      }
      if (this.state.hasDirection && this.target.classList.contains("backdrop") === false) {
        this.target.classList.add("backdrop");
      }
      if (this.state.mode === "pull") {
        this.target.style.setProperty("transform", "translateX(0)");
        this.target.style.setProperty("z-index", "0");
      }
      if (this.html.classList.contains("drawer-open")) {
        this.html.classList.remove("drawer-open");
      }
      spx.on("load", () => this.close());
    }
    onmount() {
      if (this.state.isOpen) {
        if (l.test(["lg", "xl", "xxl"])) {
          this.close();
        } else {
          setTimeout(() => this.close(), 250);
        }
      }
    }
    /**
     * Open Drawer
     */
    open() {
      if (!this.target.classList.contains("drawer-active")) {
        this.target.classList.add("drawer-active");
      }
      if (!this.backdrop.classList.contains("backdrop")) {
        this.backdrop.classList.add("backdrop");
      }
      if (this.state.bodyScroll === false) {
        this.html.style.setProperty("overflow", "hidden");
      }
      if (this.state.hasShift) {
        this.shiftElements();
      }
      if (this.state.width) {
        if (this.state.direction === "top") {
          this.backdrop.style.setProperty("transform", `translateY(-${this.state.offset})`);
        } else {
          this.backdrop.style.setProperty("transform", `translateX(${this.state.width})`);
        }
      }
      this.html.classList.add("drawer-open");
      this.backdrop.addEventListener("click", this.toggle, { once: true });
      this.target.addEventListener("touchstart", this.touchStart, { passive: true });
      this.target.ariaHidden = "false";
    }
    close() {
      if (this.state.isOpen) {
        this.state.isOpen = false;
      }
      if (this.state.width) {
        this.backdrop.style.removeProperty("transform");
      }
      if (this.state.bodyScroll === false) {
        this.html.style.removeProperty("overflow");
      }
      if (this.state.hasShift) {
        this.shiftElements();
      } else {
        this.target.addEventListener("transitionend", this.transition);
      }
      this.html.classList.remove("drawer-open");
      this.target.removeEventListener("touchstart", this.touchStart);
      this.backdrop.removeEventListener("click", this.toggle);
      this.target.classList.remove("drawer-active");
      this.target.ariaHidden = "true";
    }
    /**
     * Set attribute requirements for the elements which apply transform shifting
     */
    shiftElements() {
      if (this.state.mode === "pull") {
        this.target.style.setProperty("transform", "translateX(0)");
        this.target.style.setProperty("z-index", "0");
        if (this.state.isOpen === false) {
          this.shifts.item(0).addEventListener("transitionend", this.transition);
        }
      } else {
        if (this.state.isOpen === false) {
          this.target.addEventListener("transitionend", this.transition);
        }
      }
      for (const shift of this.shifts) {
        if (this.state.isOpen) {
          if (!shift.classList.contains(this.shiftClass)) {
            shift.classList.add(this.shiftClass);
          }
          if (this.state.width && (this.state.direction === "left" || this.state.direction === "right")) {
            shift.style.setProperty("transform", `translateX(${this.state.width})`);
          } else if (this.state.hasHeight && (this.state.direction === "top" || this.state.direction === "bottom")) {
            shift.style.setProperty("transform", `translateY(${this.state.height})`);
          }
        } else {
          if (this.state.width && (this.state.direction === "left" || this.state.direction === "right")) {
            shift.style.setProperty("transform", "translateX(0)");
          } else if (this.state.hasHeight && (this.state.direction === "top" || this.state.direction === "bottom")) {
            shift.style.setProperty("transform", "translateY(0)");
          }
        }
      }
    }
    /**
     * Touch Start scroll position
     */
    touchStart({ target }) {
      if (target instanceof HTMLElement) {
        const { scrollTop, offsetHeight } = target;
        const position = scrollTop + offsetHeight;
        if (scrollTop === 0) {
          target.scrollTop = 1;
        } else if (position === scrollTop) {
          target.scrollTop = scrollTop - 1;
        }
      }
    }
  };
  /**
   * Stimulus: values
   */
  _Drawer.define = {
    state: {
      outsideClick: Boolean,
      height: String,
      width: String,
      offset: String,
      direction: String,
      shift: String,
      redraw: String,
      useParent: {
        typeof: Boolean,
        default: false
      },
      isOpen: {
        typeof: Boolean,
        default: false
      },
      bodyScroll: {
        typeof: Boolean,
        default: false
      },
      backdrop: {
        typeof: Boolean,
        default: true
      },
      mode: {
        typeof: String,
        default: "overlay"
      }
    }
  };
  var Drawer = _Drawer;

  // src/app/components/tabs.ts
  var Tabs = class extends spx.Component {
    onmount() {
      this.state.size = this.dom.tabNodes.length;
    }
    toggle({ attrs }) {
      if (this.state.open === attrs.index)
        return;
      for (let i2 = 0, s2 = this.state.size; i2 < s2; i2++) {
        if (i2 === attrs.index) {
          this.dom.buttonNodes[i2].classList.add("active");
          this.dom.tabNodes[i2].classList.remove("d-none");
        } else {
          this.dom.buttonNodes[i2].classList.remove("active");
          this.dom.tabNodes[i2].classList.toggle("d-none", true);
        }
      }
      this.state.open = attrs.index;
    }
  };
  Tabs.define = {
    state: {
      size: Number,
      open: {
        default: 0,
        typeof: Number
      }
    },
    nodes: [
      "button",
      "tab"
    ]
  };

  // node_modules/.pnpm/papyrus@0.5.9/node_modules/papyrus/dist/papyrus.mjs
  if (typeof window !== "undefined")
    window.Prism = window.Prism || {};
  window.Prism.manual = true;
  var fn = Object.create;
  var $e = Object.defineProperty;
  var gn = Object.getOwnPropertyDescriptor;
  var hn = Object.getOwnPropertyNames;
  var mn = Object.getPrototypeOf;
  var vn = Object.prototype.hasOwnProperty;
  var bn = (r, e2) => () => (r && (e2 = r(r = 0)), e2);
  var U2 = (r, e2) => () => (e2 || r((e2 = { exports: {} }).exports, e2), e2.exports);
  var yn = (r, e2) => {
    for (var t in e2)
      $e(r, t, { get: e2[t], enumerable: true });
  };
  var St = (r, e2, t, i2) => {
    if (e2 && typeof e2 == "object" || typeof e2 == "function")
      for (let n of hn(e2))
        !vn.call(r, n) && n !== t && $e(r, n, { get: () => e2[n], enumerable: !(i2 = gn(e2, n)) || i2.enumerable });
    return r;
  };
  var W = (r, e2, t) => (t = r != null ? fn(mn(r)) : {}, St(e2 || !r || !r.__esModule ? $e(t, "default", { value: r, enumerable: true }) : t, r));
  var wn = (r) => St($e({}, "__esModule", { value: true }), r);
  var K = U2((mr, Oe) => {
    var xn = typeof window != "undefined" ? window : typeof WorkerGlobalScope != "undefined" && self instanceof WorkerGlobalScope ? self : {};
    var y = function(r) {
      var e2 = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, t = 0, i2 = {}, n = { manual: r.Prism && r.Prism.manual, disableWorkerMessageHandler: r.Prism && r.Prism.disableWorkerMessageHandler, util: { encode: function u2(l2) {
        return l2 instanceof a2 ? new a2(l2.type, u2(l2.content), l2.alias) : Array.isArray(l2) ? l2.map(u2) : l2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
      }, type: function(u2) {
        return Object.prototype.toString.call(u2).slice(8, -1);
      }, objId: function(u2) {
        return u2.__id || Object.defineProperty(u2, "__id", { value: ++t }), u2.__id;
      }, clone: function u2(l2, d2) {
        d2 = d2 || {};
        var g3, f2;
        switch (n.util.type(l2)) {
          case "Object":
            if (f2 = n.util.objId(l2), d2[f2])
              return d2[f2];
            g3 = {}, d2[f2] = g3;
            for (var A in l2)
              l2.hasOwnProperty(A) && (g3[A] = u2(l2[A], d2));
            return g3;
          case "Array":
            return f2 = n.util.objId(l2), d2[f2] ? d2[f2] : (g3 = [], d2[f2] = g3, l2.forEach(function(k2, w2) {
              g3[w2] = u2(k2, d2);
            }), g3);
          default:
            return l2;
        }
      }, getLanguage: function(u2) {
        for (; u2; ) {
          var l2 = e2.exec(u2.className);
          if (l2)
            return l2[1].toLowerCase();
          u2 = u2.parentElement;
        }
        return "none";
      }, setLanguage: function(u2, l2) {
        u2.className = u2.className.replace(RegExp(e2, "gi"), ""), u2.classList.add("language-" + l2);
      }, currentScript: function() {
        if (typeof document == "undefined")
          return null;
        if ("currentScript" in document && 1 < 2)
          return document.currentScript;
        try {
          throw new Error();
        } catch (g3) {
          var u2 = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(g3.stack) || [])[1];
          if (u2) {
            var l2 = document.getElementsByTagName("script");
            for (var d2 in l2)
              if (l2[d2].src == u2)
                return l2[d2];
          }
          return null;
        }
      }, isActive: function(u2, l2, d2) {
        for (var g3 = "no-" + l2; u2; ) {
          var f2 = u2.classList;
          if (f2.contains(l2))
            return true;
          if (f2.contains(g3))
            return false;
          u2 = u2.parentElement;
        }
        return !!d2;
      } }, languages: { plain: i2, plaintext: i2, text: i2, txt: i2, extend: function(u2, l2) {
        var d2 = n.util.clone(n.languages[u2]);
        for (var g3 in l2)
          d2[g3] = l2[g3];
        return d2;
      }, insertBefore: function(u2, l2, d2, g3) {
        g3 = g3 || n.languages;
        var f2 = g3[u2], A = {};
        for (var k2 in f2)
          if (f2.hasOwnProperty(k2)) {
            if (k2 == l2)
              for (var w2 in d2)
                d2.hasOwnProperty(w2) && (A[w2] = d2[w2]);
            d2.hasOwnProperty(k2) || (A[k2] = f2[k2]);
          }
        var N2 = g3[u2];
        return g3[u2] = A, n.languages.DFS(n.languages, function(R2, G) {
          G === N2 && R2 != u2 && (this[R2] = A);
        }), A;
      }, DFS: function u2(l2, d2, g3, f2) {
        f2 = f2 || {};
        var A = n.util.objId;
        for (var k2 in l2)
          if (l2.hasOwnProperty(k2)) {
            d2.call(l2, k2, l2[k2], g3 || k2);
            var w2 = l2[k2], N2 = n.util.type(w2);
            N2 === "Object" && !f2[A(w2)] ? (f2[A(w2)] = true, u2(w2, d2, null, f2)) : N2 === "Array" && !f2[A(w2)] && (f2[A(w2)] = true, u2(w2, d2, k2, f2));
          }
      } }, plugins: {}, highlightAll: function(u2, l2) {
        n.highlightAllUnder(document, u2, l2);
      }, highlightAllUnder: function(u2, l2, d2) {
        var g3 = { callback: d2, container: u2, selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code' };
        n.hooks.run("before-highlightall", g3), g3.elements = Array.prototype.slice.apply(g3.container.querySelectorAll(g3.selector)), n.hooks.run("before-all-elements-highlight", g3);
        for (var f2 = 0, A; A = g3.elements[f2++]; )
          n.highlightElement(A, l2 === true, g3.callback);
      }, highlightElement: function(u2, l2, d2) {
        var g3 = n.util.getLanguage(u2), f2 = n.languages[g3];
        n.util.setLanguage(u2, g3);
        var A = u2.parentElement;
        A && A.nodeName.toLowerCase() === "pre" && n.util.setLanguage(A, g3);
        var k2 = u2.textContent, w2 = { element: u2, language: g3, grammar: f2, code: k2 };
        function N2(G) {
          w2.highlightedCode = G, n.hooks.run("before-insert", w2), w2.element.innerHTML = w2.highlightedCode, n.hooks.run("after-highlight", w2), n.hooks.run("complete", w2), d2 && d2.call(w2.element);
        }
        if (n.hooks.run("before-sanity-check", w2), A = w2.element.parentElement, A && A.nodeName.toLowerCase() === "pre" && !A.hasAttribute("tabindex") && A.setAttribute("tabindex", "0"), !w2.code) {
          n.hooks.run("complete", w2), d2 && d2.call(w2.element);
          return;
        }
        if (n.hooks.run("before-highlight", w2), !w2.grammar) {
          N2(n.util.encode(w2.code));
          return;
        }
        if (l2 && r.Worker) {
          var R2 = new Worker(n.filename);
          R2.onmessage = function(G) {
            N2(G.data);
          }, R2.postMessage(JSON.stringify({ language: w2.language, code: w2.code, immediateClose: true }));
        } else
          N2(n.highlight(w2.code, w2.grammar, w2.language));
      }, highlight: function(u2, l2, d2) {
        var g3 = { code: u2, grammar: l2, language: d2 };
        if (n.hooks.run("before-tokenize", g3), !g3.grammar)
          throw new Error('The language "' + g3.language + '" has no grammar.');
        return g3.tokens = n.tokenize(g3.code, g3.grammar), n.hooks.run("after-tokenize", g3), a2.stringify(n.util.encode(g3.tokens), g3.language);
      }, tokenize: function(u2, l2) {
        var d2 = l2.rest;
        if (d2) {
          for (var g3 in d2)
            l2[g3] = d2[g3];
          delete l2.rest;
        }
        var f2 = new s2();
        return S2(f2, f2.head, u2), b2(u2, f2, l2, f2.head, 0), c(f2);
      }, hooks: { all: {}, add: function(u2, l2) {
        var d2 = n.hooks.all;
        d2[u2] = d2[u2] || [], d2[u2].push(l2);
      }, run: function(u2, l2) {
        var d2 = n.hooks.all[u2];
        if (!(!d2 || !d2.length))
          for (var g3 = 0, f2; f2 = d2[g3++]; )
            f2(l2);
      } }, Token: a2 };
      r.Prism = n;
      function a2(u2, l2, d2, g3) {
        this.type = u2, this.content = l2, this.alias = d2, this.length = (g3 || "").length | 0;
      }
      a2.stringify = function u2(l2, d2) {
        if (typeof l2 == "string")
          return l2;
        if (Array.isArray(l2)) {
          var g3 = "";
          return l2.forEach(function(N2) {
            g3 += u2(N2, d2);
          }), g3;
        }
        var f2 = { type: l2.type, content: u2(l2.content, d2), tag: "span", classes: ["token", l2.type], attributes: {}, language: d2 }, A = l2.alias;
        A && (Array.isArray(A) ? Array.prototype.push.apply(f2.classes, A) : f2.classes.push(A)), n.hooks.run("wrap", f2);
        var k2 = "";
        for (var w2 in f2.attributes)
          k2 += " " + w2 + '="' + (f2.attributes[w2] || "").replace(/"/g, "&quot;") + '"';
        return "<" + f2.tag + ' class="' + f2.classes.join(" ") + '"' + k2 + ">" + f2.content + "</" + f2.tag + ">";
      };
      function o2(u2, l2, d2, g3) {
        u2.lastIndex = l2;
        var f2 = u2.exec(d2);
        if (f2 && g3 && f2[1]) {
          var A = f2[1].length;
          f2.index += A, f2[0] = f2[0].slice(A);
        }
        return f2;
      }
      function b2(u2, l2, d2, g3, f2, A) {
        for (var k2 in d2)
          if (!(!d2.hasOwnProperty(k2) || !d2[k2])) {
            var w2 = d2[k2];
            w2 = Array.isArray(w2) ? w2 : [w2];
            for (var N2 = 0; N2 < w2.length; ++N2) {
              if (A && A.cause == k2 + "," + N2)
                return;
              var R2 = w2[N2], G = R2.inside, te = !!R2.lookbehind, M2 = !!R2.greedy, se = R2.alias;
              if (M2 && !R2.pattern.global) {
                var be = R2.pattern.toString().match(/[imsuy]*$/)[0];
                R2.pattern = RegExp(R2.pattern.source, be + "g");
              }
              for (var oe = R2.pattern || R2, j2 = g3.next, q = f2; j2 !== l2.tail && !(A && q >= A.reach); q += j2.value.length, j2 = j2.next) {
                var C2 = j2.value;
                if (l2.length > u2.length)
                  return;
                if (!(C2 instanceof a2)) {
                  var T2 = 1, $3;
                  if (M2) {
                    if ($3 = o2(oe, q, u2, te), !$3 || $3.index >= u2.length)
                      break;
                    var B = $3.index, L2 = $3.index + $3[0].length, O = q;
                    for (O += j2.value.length; B >= O; )
                      j2 = j2.next, O += j2.value.length;
                    if (O -= j2.value.length, q = O, j2.value instanceof a2)
                      continue;
                    for (var Q = j2; Q !== l2.tail && (O < L2 || typeof Q.value == "string"); Q = Q.next)
                      T2++, O += Q.value.length;
                    T2--, C2 = u2.slice(q, O), $3.index -= q;
                  } else if ($3 = o2(oe, 0, C2, te), !$3)
                    continue;
                  var B = $3.index, V = $3[0], p3 = C2.slice(0, B), h3 = C2.slice(B + V.length), m2 = q + C2.length;
                  A && m2 > A.reach && (A.reach = m2);
                  var _ = j2.prev;
                  p3 && (_ = S2(l2, _, p3), q += p3.length), E(l2, _, T2);
                  var I2 = new a2(k2, G ? n.tokenize(V, G) : V, se, V);
                  if (j2 = S2(l2, _, I2), h3 && S2(l2, j2, h3), T2 > 1) {
                    var H = { cause: k2 + "," + N2, reach: m2 };
                    b2(u2, l2, d2, j2.prev, q, H), A && H.reach > A.reach && (A.reach = H.reach);
                  }
                }
              }
            }
          }
      }
      function s2() {
        var u2 = { value: null, prev: null, next: null }, l2 = { value: null, prev: u2, next: null };
        u2.next = l2, this.head = u2, this.tail = l2, this.length = 0;
      }
      function S2(u2, l2, d2) {
        var g3 = l2.next, f2 = { value: d2, prev: l2, next: g3 };
        return l2.next = f2, g3.prev = f2, u2.length++, f2;
      }
      function E(u2, l2, d2) {
        for (var g3 = l2.next, f2 = 0; f2 < d2 && g3 !== u2.tail; f2++)
          g3 = g3.next;
        l2.next = g3, g3.prev = l2, u2.length -= f2;
      }
      function c(u2) {
        for (var l2 = [], d2 = u2.head.next; d2 !== u2.tail; )
          l2.push(d2.value), d2 = d2.next;
        return l2;
      }
      if (!r.document)
        return r.addEventListener && (n.disableWorkerMessageHandler || r.addEventListener("message", function(u2) {
          var l2 = JSON.parse(u2.data), d2 = l2.language, g3 = l2.code, f2 = l2.immediateClose;
          r.postMessage(n.highlight(g3, n.languages[d2], d2)), f2 && r.close();
        }, false)), n;
      var F2 = n.util.currentScript();
      F2 && (n.filename = F2.src, F2.hasAttribute("data-manual") && (n.manual = true));
      function x2() {
        n.manual || n.highlightAll();
      }
      if (!n.manual) {
        var v2 = document.readyState;
        v2 === "loading" || v2 === "interactive" && F2 && F2.defer ? document.addEventListener("DOMContentLoaded", x2) : window.requestAnimationFrame ? window.requestAnimationFrame(x2) : window.setTimeout(x2, 16);
      }
      return n;
    }(xn);
    typeof Oe != "undefined" && Oe.exports && (Oe.exports = y);
    typeof global != "undefined" && (global.Prism = y);
    y.languages.markup = { comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: true }, prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: true }, doctype: { pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i, greedy: true, inside: { "internal-subset": { pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/, lookbehind: true, greedy: true, inside: null }, string: { pattern: /"[^"]*"|'[^']*'/, greedy: true }, punctuation: /^<!|>$|[[\]]/, "doctype-tag": /^DOCTYPE/i, name: /[^\s<>'"]+/ } }, cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: true }, tag: { pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/, greedy: true, inside: { tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, "special-attr": [], "attr-value": { pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, inside: { punctuation: [{ pattern: /^=/, alias: "attr-equals" }, { pattern: /^(\s*)["']|["']$/, lookbehind: true }] } }, punctuation: /\/?>/, "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } } } }, entity: [{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\da-f]{1,8};/i] };
    y.languages.markup.tag.inside["attr-value"].inside.entity = y.languages.markup.entity;
    y.languages.markup.doctype.inside["internal-subset"].inside = y.languages.markup;
    y.hooks.add("wrap", function(r) {
      r.type === "entity" && (r.attributes.title = r.content.replace(/&amp;/, "&"));
    });
    Object.defineProperty(y.languages.markup.tag, "addInlined", { value: function(e2, t) {
      var i2 = {};
      i2["language-" + t] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: true, inside: y.languages[t] }, i2.cdata = /^<!\[CDATA\[|\]\]>$/i;
      var n = { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: i2 } };
      n["language-" + t] = { pattern: /[\s\S]+/, inside: y.languages[t] };
      var a2 = {};
      a2[e2] = { pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
        return e2;
      }), "i"), lookbehind: true, greedy: true, inside: n }, y.languages.insertBefore("markup", "cdata", a2);
    } });
    Object.defineProperty(y.languages.markup.tag, "addAttribute", { value: function(r, e2) {
      y.languages.markup.tag.inside["special-attr"].push({ pattern: RegExp(/(^|["'\s])/.source + "(?:" + r + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"), lookbehind: true, inside: { "attr-name": /^[^\s=]+/, "attr-value": { pattern: /=[\s\S]+/, inside: { value: { pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/, lookbehind: true, alias: [e2, "language-" + e2], inside: y.languages[e2] }, punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/] } } } });
    } });
    y.languages.html = y.languages.markup;
    y.languages.mathml = y.languages.markup;
    y.languages.svg = y.languages.markup;
    y.languages.xml = y.languages.extend("markup", {});
    y.languages.ssml = y.languages.xml;
    y.languages.atom = y.languages.xml;
    y.languages.rss = y.languages.xml;
    (function(r) {
      var e2 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      r.languages.css = { comment: /\/\*[\s\S]*?\*\//, atrule: { pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + e2.source + ")*?" + /(?:;|(?=\s*\{))/.source), inside: { rule: /^@[\w-]+/, "selector-function-argument": { pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/, lookbehind: true, alias: "selector" }, keyword: { pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/, lookbehind: true } } }, url: { pattern: RegExp("\\burl\\((?:" + e2.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"), greedy: true, inside: { function: /^url/i, punctuation: /^\(|\)$/, string: { pattern: RegExp("^" + e2.source + "$"), alias: "url" } } }, selector: { pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + e2.source + ")*(?=\\s*\\{)"), lookbehind: true }, string: { pattern: e2, greedy: true }, property: { pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i, lookbehind: true }, important: /!important\b/i, function: { pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i, lookbehind: true }, punctuation: /[(){};:,]/ }, r.languages.css.atrule.inside.rest = r.languages.css;
      var t = r.languages.markup;
      t && (t.tag.addInlined("style", "css"), t.tag.addAttribute("style", "css"));
    })(y);
    y.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true, greedy: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/, boolean: /\b(?:false|true)\b/, function: /\b\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/, punctuation: /[{}[\];(),.:]/ };
    y.languages.javascript = y.languages.extend("clike", { "class-name": [y.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/, lookbehind: true }], keyword: [{ pattern: /((?:^|\})\s*)catch\b/, lookbehind: true }, { pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, number: { pattern: RegExp(/(^|[^\w$])/.source + "(?:" + (/NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source), lookbehind: true }, operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/ });
    y.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
    y.languages.insertBefore("javascript", "keyword", { regex: { pattern: RegExp(/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source), lookbehind: true, greedy: true, inside: { "regex-source": { pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/, lookbehind: true, alias: "language-regex", inside: y.languages.regex }, "regex-delimiter": /^\/|\/$/, "regex-flags": /^[a-z]+$/ } }, "function-variable": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/, lookbehind: true, inside: y.languages.javascript }, { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i, lookbehind: true, inside: y.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/, lookbehind: true, inside: y.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/, lookbehind: true, inside: y.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ });
    y.languages.insertBefore("javascript", "string", { hashbang: { pattern: /^#!.*/, greedy: true, alias: "comment" }, "template-string": { pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/, greedy: true, inside: { "template-punctuation": { pattern: /^`|`$/, alias: "string" }, interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/, lookbehind: true, inside: { "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "punctuation" }, rest: y.languages.javascript } }, string: /[\s\S]+/ } }, "string-property": { pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m, lookbehind: true, greedy: true, alias: "property" } });
    y.languages.insertBefore("javascript", "operator", { "literal-property": { pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m, lookbehind: true, alias: "property" } });
    y.languages.markup && (y.languages.markup.tag.addInlined("script", "javascript"), y.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript"));
    y.languages.js = y.languages.javascript;
    (function() {
      if (typeof y == "undefined" || typeof document == "undefined")
        return;
      Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
      var r = "Loading\u2026", e2 = function(F2, x2) {
        return "\u2716 Error " + F2 + " while fetching file: " + x2;
      }, t = "\u2716 Error: File does not exist or is empty", i2 = { js: "javascript", py: "python", rb: "ruby", ps1: "powershell", psm1: "powershell", sh: "bash", bat: "batch", h: "c", tex: "latex" }, n = "data-src-status", a2 = "loading", o2 = "loaded", b2 = "failed", s2 = "pre[data-src]:not([" + n + '="' + o2 + '"]):not([' + n + '="' + a2 + '"])';
      function S2(F2, x2, v2) {
        var u2 = new XMLHttpRequest();
        u2.open("GET", F2, true), u2.onreadystatechange = function() {
          u2.readyState == 4 && (u2.status < 400 && u2.responseText ? x2(u2.responseText) : u2.status >= 400 ? v2(e2(u2.status, u2.statusText)) : v2(t));
        }, u2.send(null);
      }
      function E(F2) {
        var x2 = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(F2 || "");
        if (x2) {
          var v2 = Number(x2[1]), u2 = x2[2], l2 = x2[3];
          return u2 ? l2 ? [v2, Number(l2)] : [v2, void 0] : [v2, v2];
        }
      }
      y.hooks.add("before-highlightall", function(F2) {
        F2.selector += ", " + s2;
      }), y.hooks.add("before-sanity-check", function(F2) {
        var x2 = F2.element;
        if (x2.matches(s2)) {
          F2.code = "", x2.setAttribute(n, a2);
          var v2 = x2.appendChild(document.createElement("CODE"));
          v2.textContent = r;
          var u2 = x2.getAttribute("data-src"), l2 = F2.language;
          if (l2 === "none") {
            var d2 = (/\.(\w+)$/.exec(u2) || [, "none"])[1];
            l2 = i2[d2] || d2;
          }
          y.util.setLanguage(v2, l2), y.util.setLanguage(x2, l2);
          var g3 = y.plugins.autoloader;
          g3 && g3.loadLanguages(l2), S2(u2, function(f2) {
            x2.setAttribute(n, o2);
            var A = E(x2.getAttribute("data-range"));
            if (A) {
              var k2 = f2.split(/\r\n?|\n/g), w2 = A[0], N2 = A[1] == null ? k2.length : A[1];
              w2 < 0 && (w2 += k2.length), w2 = Math.max(0, Math.min(w2 - 1, k2.length)), N2 < 0 && (N2 += k2.length), N2 = Math.max(0, Math.min(N2, k2.length)), f2 = k2.slice(w2, N2).join(`
`), x2.hasAttribute("data-start") || x2.setAttribute("data-start", String(w2 + 1));
            }
            v2.textContent = f2, y.highlightElement(v2);
          }, function(f2) {
            x2.setAttribute(n, b2), v2.textContent = f2;
          });
        }
      }), y.plugins.fileHighlight = { highlight: function(x2) {
        for (var v2 = (x2 || document).querySelectorAll(s2), u2 = 0, l2; l2 = v2[u2++]; )
          y.highlightElement(l2);
      } };
      var c = false;
      y.fileHighlight = function() {
        c || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."), c = true), y.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
  });
  var Le = U2((Yr, lt) => {
    var Mn = Object.prototype.hasOwnProperty, X = "~";
    function Fe() {
    }
    Object.create && (Fe.prototype = /* @__PURE__ */ Object.create(null), new Fe().__proto__ || (X = false));
    function Rn(r, e2, t) {
      this.fn = r, this.context = e2, this.once = t || false;
    }
    function Zt(r, e2, t, i2, n) {
      if (typeof t != "function")
        throw new TypeError("The listener must be a function");
      var a2 = new Rn(t, i2 || r, n), o2 = X ? X + e2 : e2;
      return r._events[o2] ? r._events[o2].fn ? r._events[o2] = [r._events[o2], a2] : r._events[o2].push(a2) : (r._events[o2] = a2, r._eventsCount++), r;
    }
    function ze(r, e2) {
      --r._eventsCount === 0 ? r._events = new Fe() : delete r._events[e2];
    }
    function Z() {
      this._events = new Fe(), this._eventsCount = 0;
    }
    Z.prototype.eventNames = function() {
      var e2 = [], t, i2;
      if (this._eventsCount === 0)
        return e2;
      for (i2 in t = this._events)
        Mn.call(t, i2) && e2.push(X ? i2.slice(1) : i2);
      return Object.getOwnPropertySymbols ? e2.concat(Object.getOwnPropertySymbols(t)) : e2;
    };
    Z.prototype.listeners = function(e2) {
      var t = X ? X + e2 : e2, i2 = this._events[t];
      if (!i2)
        return [];
      if (i2.fn)
        return [i2.fn];
      for (var n = 0, a2 = i2.length, o2 = new Array(a2); n < a2; n++)
        o2[n] = i2[n].fn;
      return o2;
    };
    Z.prototype.listenerCount = function(e2) {
      var t = X ? X + e2 : e2, i2 = this._events[t];
      return i2 ? i2.fn ? 1 : i2.length : 0;
    };
    Z.prototype.emit = function(e2, t, i2, n, a2, o2) {
      var b2 = X ? X + e2 : e2;
      if (!this._events[b2])
        return false;
      var s2 = this._events[b2], S2 = arguments.length, E, c;
      if (s2.fn) {
        switch (s2.once && this.removeListener(e2, s2.fn, void 0, true), S2) {
          case 1:
            return s2.fn.call(s2.context), true;
          case 2:
            return s2.fn.call(s2.context, t), true;
          case 3:
            return s2.fn.call(s2.context, t, i2), true;
          case 4:
            return s2.fn.call(s2.context, t, i2, n), true;
          case 5:
            return s2.fn.call(s2.context, t, i2, n, a2), true;
          case 6:
            return s2.fn.call(s2.context, t, i2, n, a2, o2), true;
        }
        for (c = 1, E = new Array(S2 - 1); c < S2; c++)
          E[c - 1] = arguments[c];
        s2.fn.apply(s2.context, E);
      } else {
        var F2 = s2.length, x2;
        for (c = 0; c < F2; c++)
          switch (s2[c].once && this.removeListener(e2, s2[c].fn, void 0, true), S2) {
            case 1:
              s2[c].fn.call(s2[c].context);
              break;
            case 2:
              s2[c].fn.call(s2[c].context, t);
              break;
            case 3:
              s2[c].fn.call(s2[c].context, t, i2);
              break;
            case 4:
              s2[c].fn.call(s2[c].context, t, i2, n);
              break;
            default:
              if (!E)
                for (x2 = 1, E = new Array(S2 - 1); x2 < S2; x2++)
                  E[x2 - 1] = arguments[x2];
              s2[c].fn.apply(s2[c].context, E);
          }
      }
      return true;
    };
    Z.prototype.on = function(e2, t, i2) {
      return Zt(this, e2, t, i2, false);
    };
    Z.prototype.once = function(e2, t, i2) {
      return Zt(this, e2, t, i2, true);
    };
    Z.prototype.removeListener = function(e2, t, i2, n) {
      var a2 = X ? X + e2 : e2;
      if (!this._events[a2])
        return this;
      if (!t)
        return ze(this, a2), this;
      var o2 = this._events[a2];
      if (o2.fn)
        o2.fn === t && (!n || o2.once) && (!i2 || o2.context === i2) && ze(this, a2);
      else {
        for (var b2 = 0, s2 = [], S2 = o2.length; b2 < S2; b2++)
          (o2[b2].fn !== t || n && !o2[b2].once || i2 && o2[b2].context !== i2) && s2.push(o2[b2]);
        s2.length ? this._events[a2] = s2.length === 1 ? s2[0] : s2 : ze(this, a2);
      }
      return this;
    };
    Z.prototype.removeAllListeners = function(e2) {
      var t;
      return e2 ? (t = X ? X + e2 : e2, this._events[t] && ze(this, t)) : (this._events = new Fe(), this._eventsCount = 0), this;
    };
    Z.prototype.off = Z.prototype.removeListener;
    Z.prototype.addListener = Z.prototype.on;
    Z.prefixed = X;
    Z.EventEmitter = Z;
    typeof lt != "undefined" && (lt.exports = Z);
  });
  var ct = U2((He) => {
    Object.defineProperty(He, "__esModule", { value: true });
    He.SearchResult = void 0;
    var jn = /\$&/g, zn = /\$(\d)/g, ut = class {
      constructor(e2, t, i2) {
        this.data = e2, this.term = t, this.strategy = i2;
      }
      getReplacementData(e2) {
        let t = this.strategy.replace(this.data);
        if (t == null)
          return null;
        let i2 = "";
        Array.isArray(t) && (i2 = t[1], t = t[0]);
        let n = this.strategy.match(e2);
        if (n == null || n.index == null)
          return null;
        let a2 = t.replace(jn, n[0]).replace(zn, (o2, b2) => n[parseInt(b2)]);
        return { start: n.index, end: n.index + n[0].length, beforeCursor: a2, afterCursor: i2 };
      }
      replace(e2, t) {
        let i2 = this.getReplacementData(e2);
        if (i2 !== null)
          return t = i2.afterCursor + t, [[e2.slice(0, i2.start), i2.beforeCursor, e2.slice(i2.end)].join(""), t];
      }
      render() {
        return this.strategy.renderTemplate(this.data, this.term);
      }
      getStrategyId() {
        return this.strategy.getId();
      }
    };
    He.SearchResult = ut;
  });
  var pt = U2((me) => {
    Object.defineProperty(me, "__esModule", { value: true });
    me.Strategy = me.DEFAULT_INDEX = void 0;
    var Hn = ct();
    me.DEFAULT_INDEX = 1;
    var dt = class {
      constructor(e2) {
        this.props = e2, this.cache = {};
      }
      destroy() {
        return this.cache = {}, this;
      }
      replace(e2) {
        return this.props.replace(e2);
      }
      execute(e2, t) {
        var i2;
        let n = this.matchWithContext(e2);
        if (!n)
          return false;
        let a2 = n[(i2 = this.props.index) !== null && i2 !== void 0 ? i2 : me.DEFAULT_INDEX];
        return this.search(a2, (o2) => {
          t(o2.map((b2) => new Hn.SearchResult(b2, a2, this)));
        }, n), true;
      }
      renderTemplate(e2, t) {
        if (this.props.template)
          return this.props.template(e2, t);
        if (typeof e2 == "string")
          return e2;
        throw new Error(`Unexpected render data type: ${typeof e2}. Please implement template parameter by yourself`);
      }
      getId() {
        return this.props.id || null;
      }
      match(e2) {
        return typeof this.props.match == "function" ? this.props.match(e2) : e2.match(this.props.match);
      }
      search(e2, t, i2) {
        this.props.cache ? this.searchWithCach(e2, t, i2) : this.props.search(e2, t, i2);
      }
      matchWithContext(e2) {
        let t = this.context(e2);
        return t === false ? null : this.match(t === true ? e2 : t);
      }
      context(e2) {
        return this.props.context ? this.props.context(e2) : true;
      }
      searchWithCach(e2, t, i2) {
        this.cache[e2] != null ? t(this.cache[e2]) : this.props.search(e2, (n) => {
          this.cache[e2] = n, t(n);
        }, i2);
      }
    };
    me.Strategy = dt;
  });
  var gt = U2((qe) => {
    Object.defineProperty(qe, "__esModule", { value: true });
    qe.Completer = void 0;
    var qn = Le(), Un = pt(), ft = class extends qn.EventEmitter {
      constructor(e2) {
        super(), this.handleQueryResult = (t) => {
          this.emit("hit", { searchResults: t });
        }, this.strategies = e2.map((t) => new Un.Strategy(t));
      }
      destroy() {
        return this.strategies.forEach((e2) => e2.destroy()), this;
      }
      run(e2) {
        for (let t of this.strategies)
          if (t.execute(e2, this.handleQueryResult))
            return;
        this.handleQueryResult([]);
      }
    };
    qe.Completer = ft;
  });
  var Be = U2((Ue) => {
    Object.defineProperty(Ue, "__esModule", { value: true });
    Ue.createCustomEvent = void 0;
    var Bn = typeof window != "undefined" && !!window.CustomEvent, Wn = (r, e2) => {
      if (Bn)
        return new CustomEvent(r, e2);
      let t = document.createEvent("CustomEvent");
      return t.initCustomEvent(r, false, (e2 == null ? void 0 : e2.cancelable) || false, (e2 == null ? void 0 : e2.detail) || void 0), t;
    };
    Ue.createCustomEvent = Wn;
  });
  var vt = U2((z) => {
    Object.defineProperty(z, "__esModule", { value: true });
    z.Dropdown = z.DEFAULT_DROPDOWN_ITEM_ACTIVE_CLASS_NAME = z.DEFAULT_DROPDOWN_ITEM_CLASS_NAME = z.DEFAULT_DROPDOWN_CLASS_NAME = z.DEFAULT_DROPDOWN_PLACEMENT = z.DEFAULT_DROPDOWN_MAX_COUNT = void 0;
    var Zn = Le(), pe = Be();
    z.DEFAULT_DROPDOWN_MAX_COUNT = 10;
    z.DEFAULT_DROPDOWN_PLACEMENT = "auto";
    z.DEFAULT_DROPDOWN_CLASS_NAME = "dropdown-menu textcomplete-dropdown";
    z.DEFAULT_DROPDOWN_ITEM_CLASS_NAME = "textcomplete-item";
    z.DEFAULT_DROPDOWN_ITEM_ACTIVE_CLASS_NAME = `${z.DEFAULT_DROPDOWN_ITEM_CLASS_NAME} active`;
    var ht = class r extends Zn.EventEmitter {
      static create(e2) {
        let t = document.createElement("ul");
        t.className = e2.className || z.DEFAULT_DROPDOWN_CLASS_NAME, Object.assign(t.style, { display: "none", position: "absolute", zIndex: "1000" }, e2.style);
        let i2 = e2.parent || document.body;
        return i2 == null || i2.appendChild(t), new r(t, e2);
      }
      constructor(e2, t) {
        super(), this.el = e2, this.option = t, this.shown = false, this.items = [], this.activeIndex = null;
      }
      render(e2, t) {
        let i2 = (0, pe.createCustomEvent)("render", { cancelable: true });
        return this.emit("render", i2), i2.defaultPrevented ? this : (this.clear(), e2.length === 0 ? this.hide() : (this.items = e2.slice(0, this.option.maxCount || z.DEFAULT_DROPDOWN_MAX_COUNT).map((n, a2) => {
          var o2;
          return new mt(this, a2, n, ((o2 = this.option) === null || o2 === void 0 ? void 0 : o2.item) || {});
        }), this.setStrategyId(e2[0]).renderEdge(e2, "header").renderItems().renderEdge(e2, "footer").show().setOffset(t).activate(0), this.emit("rendered", (0, pe.createCustomEvent)("rendered")), this));
      }
      destroy() {
        var e2;
        return this.clear(), (e2 = this.el.parentNode) === null || e2 === void 0 || e2.removeChild(this.el), this;
      }
      select(e2) {
        let t = { searchResult: e2.searchResult }, i2 = (0, pe.createCustomEvent)("select", { cancelable: true, detail: t });
        return this.emit("select", i2), i2.defaultPrevented ? this : (this.hide(), this.emit("selected", (0, pe.createCustomEvent)("selected", { detail: t })), this);
      }
      show() {
        if (!this.shown) {
          let e2 = (0, pe.createCustomEvent)("show", { cancelable: true });
          if (this.emit("show", e2), e2.defaultPrevented)
            return this;
          this.el.style.display = "block", this.shown = true, this.emit("shown", (0, pe.createCustomEvent)("shown"));
        }
        return this;
      }
      hide() {
        if (this.shown) {
          let e2 = (0, pe.createCustomEvent)("hide", { cancelable: true });
          if (this.emit("hide", e2), e2.defaultPrevented)
            return this;
          this.el.style.display = "none", this.shown = false, this.clear(), this.emit("hidden", (0, pe.createCustomEvent)("hidden"));
        }
        return this;
      }
      clear() {
        return this.items.forEach((e2) => e2.destroy()), this.items = [], this.el.innerHTML = "", this.activeIndex = null, this;
      }
      up(e2) {
        return this.shown ? this.moveActiveItem("prev", e2) : this;
      }
      down(e2) {
        return this.shown ? this.moveActiveItem("next", e2) : this;
      }
      moveActiveItem(e2, t) {
        if (this.activeIndex != null) {
          let i2 = e2 === "next" ? this.getNextActiveIndex() : this.getPrevActiveIndex();
          i2 != null && (this.activate(i2), t.preventDefault());
        }
        return this;
      }
      activate(e2) {
        return this.activeIndex !== e2 && (this.activeIndex != null && this.items[this.activeIndex].deactivate(), this.activeIndex = e2, this.items[e2].activate()), this;
      }
      isShown() {
        return this.shown;
      }
      getActiveItem() {
        return this.activeIndex != null ? this.items[this.activeIndex] : null;
      }
      setOffset(e2) {
        let t = document.documentElement;
        if (t) {
          let i2 = this.el.offsetWidth;
          if (e2.left) {
            let o2 = this.option.dynamicWidth ? t.scrollWidth : t.clientWidth;
            e2.left + i2 > o2 && (e2.left = o2 - i2), this.el.style.left = `${e2.left}px`;
          } else
            e2.right && (e2.right - i2 < 0 && (e2.right = 0), this.el.style.right = `${e2.right}px`);
          let n = false, a2 = this.option.placement || z.DEFAULT_DROPDOWN_PLACEMENT;
          if (a2 === "auto") {
            let o2 = this.items.length * e2.lineHeight;
            n = e2.clientTop != null && e2.clientTop + o2 > t.clientHeight;
          }
          a2 === "top" || n ? (this.el.style.bottom = `${t.clientHeight - e2.top + e2.lineHeight}px`, this.el.style.top = "auto") : (this.el.style.top = `${e2.top}px`, this.el.style.bottom = "auto");
        }
        return this;
      }
      getNextActiveIndex() {
        if (this.activeIndex == null)
          throw new Error();
        return this.activeIndex < this.items.length - 1 ? this.activeIndex + 1 : this.option.rotate ? 0 : null;
      }
      getPrevActiveIndex() {
        if (this.activeIndex == null)
          throw new Error();
        return this.activeIndex !== 0 ? this.activeIndex - 1 : this.option.rotate ? this.items.length - 1 : null;
      }
      renderItems() {
        let e2 = document.createDocumentFragment();
        for (let t of this.items)
          e2.appendChild(t.el);
        return this.el.appendChild(e2), this;
      }
      setStrategyId(e2) {
        let t = e2.getStrategyId();
        return t && (this.el.dataset.strategy = t), this;
      }
      renderEdge(e2, t) {
        let i2 = this.option[t], n = document.createElement("li");
        return n.className = `textcomplete-${t}`, n.innerHTML = typeof i2 == "function" ? i2(e2.map((a2) => a2.data)) : i2 || "", this.el.appendChild(n), this;
      }
    };
    z.Dropdown = ht;
    var mt = class {
      constructor(e2, t, i2, n) {
        this.dropdown = e2, this.index = t, this.searchResult = i2, this.props = n, this.active = false, this.onClick = (b2) => {
          b2.preventDefault(), this.dropdown.select(this);
        }, this.className = this.props.className || z.DEFAULT_DROPDOWN_ITEM_CLASS_NAME, this.activeClassName = this.props.activeClassName || z.DEFAULT_DROPDOWN_ITEM_ACTIVE_CLASS_NAME;
        let a2 = document.createElement("li");
        a2.className = this.active ? this.activeClassName : this.className;
        let o2 = document.createElement("span");
        o2.tabIndex = -1, o2.innerHTML = this.searchResult.render(), a2.appendChild(o2), a2.addEventListener("click", this.onClick), this.el = a2;
      }
      destroy() {
        var e2;
        let t = this.el;
        return (e2 = t.parentNode) === null || e2 === void 0 || e2.removeChild(t), t.removeEventListener("click", this.onClick, false), this;
      }
      activate() {
        return this.active || (this.active = true, this.el.className = this.activeClassName, this.dropdown.el.scrollTop = this.el.offsetTop), this;
      }
      deactivate() {
        return this.active && (this.active = false, this.el.className = this.className), this;
      }
    };
  });
  var Gt = U2((Ze) => {
    Object.defineProperty(Ze, "__esModule", { value: true });
    Ze.Editor = void 0;
    var Gn = Le(), We = Be(), bt = class extends Gn.EventEmitter {
      destroy() {
        return this;
      }
      applySearchResult(e2) {
        throw new Error("Not implemented.");
      }
      getCursorOffset() {
        throw new Error("Not implemented.");
      }
      getBeforeCursor() {
        throw new Error("Not implemented.");
      }
      emitMoveEvent(e2) {
        let t = (0, We.createCustomEvent)("move", { cancelable: true, detail: { code: e2 } });
        return this.emit("move", t), t;
      }
      emitEnterEvent() {
        let e2 = (0, We.createCustomEvent)("enter", { cancelable: true });
        return this.emit("enter", e2), e2;
      }
      emitChangeEvent() {
        let e2 = (0, We.createCustomEvent)("change", { detail: { beforeCursor: this.getBeforeCursor() } });
        return this.emit("change", e2), e2;
      }
      emitEscEvent() {
        let e2 = (0, We.createCustomEvent)("esc", { cancelable: true });
        return this.emit("esc", e2), e2;
      }
      getCode(e2) {
        switch (e2.keyCode) {
          case 9:
          case 13:
            return "ENTER";
          case 27:
            return "ESC";
          case 38:
            return "UP";
          case 40:
            return "DOWN";
          case 78:
            if (e2.ctrlKey)
              return "DOWN";
            break;
          case 80:
            if (e2.ctrlKey)
              return "UP";
            break;
        }
        return "OTHER";
      }
    };
    Ze.Editor = bt;
  });
  var Vt = U2((Ge) => {
    Object.defineProperty(Ge, "__esModule", { value: true });
    Ge.Textcomplete = void 0;
    var Vn = Le(), Kn = vt(), Xn = gt(), Qn = ["show", "shown", "render", "rendered", "selected", "hidden", "hide"], yt = class extends Vn.EventEmitter {
      constructor(e2, t, i2) {
        super(), this.editor = e2, this.isQueryInFlight = false, this.nextPendingQuery = null, this.handleHit = ({ searchResults: n }) => {
          n.length ? this.dropdown.render(n, this.editor.getCursorOffset()) : this.dropdown.hide(), this.isQueryInFlight = false, this.nextPendingQuery !== null && this.trigger(this.nextPendingQuery);
        }, this.handleMove = (n) => {
          n.detail.code === "UP" ? this.dropdown.up(n) : this.dropdown.down(n);
        }, this.handleEnter = (n) => {
          let a2 = this.dropdown.getActiveItem();
          a2 ? (this.dropdown.select(a2), n.preventDefault()) : this.dropdown.hide();
        }, this.handleEsc = (n) => {
          this.dropdown.isShown() && (this.dropdown.hide(), n.preventDefault());
        }, this.handleChange = (n) => {
          n.detail.beforeCursor != null ? this.trigger(n.detail.beforeCursor) : this.dropdown.hide();
        }, this.handleSelect = (n) => {
          this.emit("select", n), n.defaultPrevented || this.editor.applySearchResult(n.detail.searchResult);
        }, this.handleResize = () => {
          this.dropdown.isShown() && this.dropdown.setOffset(this.editor.getCursorOffset());
        }, this.completer = new Xn.Completer(t), this.dropdown = Kn.Dropdown.create((i2 == null ? void 0 : i2.dropdown) || {}), this.startListening();
      }
      destroy(e2 = true) {
        return this.completer.destroy(), this.dropdown.destroy(), e2 && this.editor.destroy(), this.stopListening(), this;
      }
      isShown() {
        return this.dropdown.isShown();
      }
      hide() {
        return this.dropdown.hide(), this;
      }
      trigger(e2) {
        return this.isQueryInFlight ? this.nextPendingQuery = e2 : (this.isQueryInFlight = true, this.nextPendingQuery = null, this.completer.run(e2)), this;
      }
      startListening() {
        var e2;
        this.editor.on("move", this.handleMove).on("enter", this.handleEnter).on("esc", this.handleEsc).on("change", this.handleChange), this.dropdown.on("select", this.handleSelect);
        for (let t of Qn)
          this.dropdown.on(t, (i2) => this.emit(t, i2));
        this.completer.on("hit", this.handleHit), (e2 = this.dropdown.el.ownerDocument.defaultView) === null || e2 === void 0 || e2.addEventListener("resize", this.handleResize);
      }
      stopListening() {
        var e2;
        (e2 = this.dropdown.el.ownerDocument.defaultView) === null || e2 === void 0 || e2.removeEventListener("resize", this.handleResize), this.completer.removeAllListeners(), this.dropdown.removeAllListeners(), this.editor.removeListener("move", this.handleMove).removeListener("enter", this.handleEnter).removeListener("esc", this.handleEsc).removeListener("change", this.handleChange);
      }
    };
    Ge.Textcomplete = yt;
  });
  var wt = U2((ee) => {
    var Yn = ee && ee.__createBinding || (Object.create ? function(r, e2, t, i2) {
      i2 === void 0 && (i2 = t);
      var n = Object.getOwnPropertyDescriptor(e2, t);
      (!n || ("get" in n ? !e2.__esModule : n.writable || n.configurable)) && (n = { enumerable: true, get: function() {
        return e2[t];
      } }), Object.defineProperty(r, i2, n);
    } : function(r, e2, t, i2) {
      i2 === void 0 && (i2 = t), r[i2] = e2[t];
    }), ve = ee && ee.__exportStar || function(r, e2) {
      for (var t in r)
        t !== "default" && !Object.prototype.hasOwnProperty.call(e2, t) && Yn(e2, r, t);
    };
    Object.defineProperty(ee, "__esModule", { value: true });
    ve(gt(), ee);
    ve(vt(), ee);
    ve(Gt(), ee);
    ve(ct(), ee);
    ve(pt(), ee);
    ve(Vt(), ee);
    ve(Be(), ee);
  });
  var Xt = {};
  yn(Xt, { update: () => Kt, wrapCursor: () => Jn });
  function Kt(r, e2, t) {
    let i2 = r.value, n = e2 + (t || ""), a2 = document.activeElement, o2 = 0, b2 = 0;
    for (; o2 < i2.length && o2 < n.length && i2[o2] === n[o2]; )
      o2++;
    for (; i2.length - b2 - 1 >= 0 && n.length - b2 - 1 >= 0 && i2[i2.length - b2 - 1] === n[n.length - b2 - 1]; )
      b2++;
    o2 = Math.min(o2, Math.min(i2.length, n.length) - b2), r.setSelectionRange(o2, i2.length - b2);
    let s2 = n.substring(o2, n.length - b2);
    if (r.focus(), !document.execCommand("insertText", false, s2)) {
      r.value = n;
      let S2 = document.createEvent("Event");
      S2.initEvent("input", true, true), r.dispatchEvent(S2);
    }
    return r.setSelectionRange(e2.length, e2.length), a2.focus(), r;
  }
  function Jn(r, e2, t) {
    let i2 = r.selectionEnd, n = r.value.substr(0, r.selectionStart) + e2, a2 = r.value.substring(r.selectionStart, i2) + (t || "") + r.value.substr(i2);
    return Kt(r, n, a2), r.selectionEnd = i2 + e2.length, r;
  }
  var Qt = bn(() => {
  });
  var Yt = U2((oi, Ve) => {
    (function() {
      var r = ["direction", "boxSizing", "width", "height", "overflowX", "overflowY", "borderTopWidth", "borderRightWidth", "borderBottomWidth", "borderLeftWidth", "borderStyle", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "fontStyle", "fontVariant", "fontWeight", "fontStretch", "fontSize", "fontSizeAdjust", "lineHeight", "fontFamily", "textAlign", "textTransform", "textIndent", "textDecoration", "letterSpacing", "wordSpacing", "tabSize", "MozTabSize"], e2 = typeof window != "undefined", t = e2 && window.mozInnerScreenX != null;
      function i2(n, a2, o2) {
        if (!e2)
          throw new Error("textarea-caret-position#getCaretCoordinates should only be called in a browser");
        var b2 = o2 && o2.debug || false;
        if (b2) {
          var s2 = document.querySelector("#input-textarea-caret-position-mirror-div");
          s2 && s2.parentNode.removeChild(s2);
        }
        var S2 = document.createElement("div");
        S2.id = "input-textarea-caret-position-mirror-div", document.body.appendChild(S2);
        var E = S2.style, c = window.getComputedStyle ? window.getComputedStyle(n) : n.currentStyle, F2 = n.nodeName === "INPUT";
        E.whiteSpace = "pre-wrap", F2 || (E.wordWrap = "break-word"), E.position = "absolute", b2 || (E.visibility = "hidden"), r.forEach(function(u2) {
          F2 && u2 === "lineHeight" ? E.lineHeight = c.height : E[u2] = c[u2];
        }), t ? n.scrollHeight > parseInt(c.height) && (E.overflowY = "scroll") : E.overflow = "hidden", S2.textContent = n.value.substring(0, a2), F2 && (S2.textContent = S2.textContent.replace(/\s/g, "\xA0"));
        var x2 = document.createElement("span");
        x2.textContent = n.value.substring(a2) || ".", S2.appendChild(x2);
        var v2 = { top: x2.offsetTop + parseInt(c.borderTopWidth), left: x2.offsetLeft + parseInt(c.borderLeftWidth), height: parseInt(c.lineHeight) };
        return b2 ? x2.style.backgroundColor = "#aaa" : document.body.removeChild(S2), v2;
      }
      typeof Ve != "undefined" && typeof Ve.exports != "undefined" ? Ve.exports = i2 : e2 && (window.getCaretCoordinates = i2);
    })();
  });
  var Jt = U2((Ke) => {
    Object.defineProperty(Ke, "__esModule", { value: true });
    Ke.calculateElementOffset = void 0;
    var er = (r) => {
      let e2 = r.getBoundingClientRect(), t = r.ownerDocument;
      if (t == null)
        throw new Error("Given element does not belong to document");
      let { defaultView: i2, documentElement: n } = t;
      if (i2 == null)
        throw new Error("Given element does not belong to window");
      let a2 = { top: e2.top + i2.pageYOffset, left: e2.left + i2.pageXOffset };
      return n && (a2.top -= n.clientTop, a2.left -= n.clientLeft), a2;
    };
    Ke.calculateElementOffset = er;
  });
  var tn = U2((Xe) => {
    Object.defineProperty(Xe, "__esModule", { value: true });
    Xe.getLineHeightPx = void 0;
    var tr = 48, nr = 57, en = (r) => tr <= r && r <= nr, rr = (r) => {
      let e2 = getComputedStyle(r), t = e2.lineHeight;
      if (en(t.charCodeAt(0))) {
        let i2 = parseFloat(t);
        return en(t.charCodeAt(t.length - 1)) ? i2 * parseFloat(e2.fontSize) : i2;
      }
      return ir(r.nodeName, e2);
    };
    Xe.getLineHeightPx = rr;
    var ir = (r, e2) => {
      let t = document.body;
      if (!t)
        return 0;
      let i2 = document.createElement(r);
      i2.innerHTML = "&nbsp;", Object.assign(i2.style, { fontSize: e2.fontSize, fontFamily: e2.fontFamily, padding: "0" }), t.appendChild(i2), i2 instanceof HTMLTextAreaElement && (i2.rows = 1);
      let n = i2.offsetHeight;
      return t.removeChild(i2), n;
    };
  });
  var nn = U2((Qe) => {
    Object.defineProperty(Qe, "__esModule", { value: true });
    Qe.isSafari = void 0;
    var ar = () => /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    Qe.isSafari = ar;
  });
  var rn = U2((ae) => {
    var sr = ae && ae.__createBinding || (Object.create ? function(r, e2, t, i2) {
      i2 === void 0 && (i2 = t);
      var n = Object.getOwnPropertyDescriptor(e2, t);
      (!n || ("get" in n ? !e2.__esModule : n.writable || n.configurable)) && (n = { enumerable: true, get: function() {
        return e2[t];
      } }), Object.defineProperty(r, i2, n);
    } : function(r, e2, t, i2) {
      i2 === void 0 && (i2 = t), r[i2] = e2[t];
    }), xt = ae && ae.__exportStar || function(r, e2) {
      for (var t in r)
        t !== "default" && !Object.prototype.hasOwnProperty.call(e2, t) && sr(e2, r, t);
    };
    Object.defineProperty(ae, "__esModule", { value: true });
    xt(Jt(), ae);
    xt(tn(), ae);
    xt(nn(), ae);
  });
  var on2 = U2((Ee) => {
    var or = Ee && Ee.__importDefault || function(r) {
      return r && r.__esModule ? r : { default: r };
    };
    Object.defineProperty(Ee, "__esModule", { value: true });
    Ee.TextareaEditor = void 0;
    var lr = (Qt(), wn(Xt)), ur = or(Yt()), an = wt(), sn = rn(), Et = class extends an.Editor {
      constructor(e2) {
        super(), this.el = e2, this.onInput = () => {
          this.emitChangeEvent();
        }, this.onKeydown = (t) => {
          let i2 = this.getCode(t), n;
          i2 === "UP" || i2 === "DOWN" ? n = this.emitMoveEvent(i2) : i2 === "ENTER" ? n = this.emitEnterEvent() : i2 === "ESC" && (n = this.emitEscEvent()), n && n.defaultPrevented && t.preventDefault();
        }, this.startListening();
      }
      destroy() {
        return super.destroy(), this.stopListening(), this;
      }
      applySearchResult(e2) {
        let t = this.getBeforeCursor();
        if (t != null) {
          let i2 = e2.replace(t, this.getAfterCursor());
          this.el.focus(), Array.isArray(i2) && ((0, lr.update)(this.el, i2[0], i2[1]), this.el && this.el.dispatchEvent((0, an.createCustomEvent)("input")));
        }
      }
      getCursorOffset() {
        let e2 = (0, sn.calculateElementOffset)(this.el), t = this.getElScroll(), i2 = this.getCursorPosition(), n = (0, sn.getLineHeightPx)(this.el), a2 = e2.top - t.top + i2.top + n, o2 = e2.left - t.left + i2.left, b2 = this.el.getBoundingClientRect().top;
        if (this.el.dir !== "rtl")
          return { top: a2, left: o2, lineHeight: n, clientTop: b2 };
        {
          let s2 = document.documentElement ? document.documentElement.clientWidth - o2 : 0;
          return { top: a2, right: s2, lineHeight: n, clientTop: b2 };
        }
      }
      getBeforeCursor() {
        return this.el.selectionStart !== this.el.selectionEnd ? null : this.el.value.substring(0, this.el.selectionEnd);
      }
      getAfterCursor() {
        return this.el.value.substring(this.el.selectionEnd);
      }
      getElScroll() {
        return { top: this.el.scrollTop, left: this.el.scrollLeft };
      }
      getCursorPosition() {
        return (0, ur.default)(this.el, this.el.selectionEnd);
      }
      startListening() {
        this.el.addEventListener("input", this.onInput), this.el.addEventListener("keydown", this.onKeydown);
      }
      stopListening() {
        this.el.removeEventListener("input", this.onInput), this.el.removeEventListener("keydown", this.onKeydown);
      }
    };
    Ee.TextareaEditor = Et;
  });
  var ln = U2((Ye) => {
    Object.defineProperty(Ye, "__esModule", { value: true });
    Ye.TextareaEditor = void 0;
    var cr = on2();
    Object.defineProperty(Ye, "TextareaEditor", { enumerable: true, get: function() {
      return cr.TextareaEditor;
    } });
  });
  var re = /* @__PURE__ */ new Map();
  var he = W(K());
  var Ne = W(K());
  var P2 = W(K());
  function Ct() {
    let r = [{ pattern: /^=/, alias: "attr-equals" }, { pattern: /^(\s*)["']|["']$/, lookbehind: true }];
    return P2.default.languages.markup = { comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: true }, prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: true }, doctype: { pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i, greedy: true, inside: { "internal-subset": { pattern: /(^[^[]*\[)[\s\S]+(?=\]>$)/, lookbehind: true, greedy: true, inside: null }, string: { pattern: /"[^"]*"|'[^']*'/, greedy: true }, punctuation: /^<!|>$|[[\]]/, "doctype-tag": /^DOCTYPE/i, name: /[^\s<>'"]+/ } }, cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: true }, tag: { pattern: /<\/?(?!\d)[^\s>/=$<%]+(?:\s(?:\s*[^\s>/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/, greedy: true, inside: { tag: { pattern: /^<\/?[^\s>/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>/:]+:/ } }, "special-attr": [], "spx-attr": [{ pattern: /(spx-node)=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, lookbehind: true, global: true, inside: { "dot-notation": { pattern: /[a-zA-Z0-9]+\.[a-zA-Z0-9]+/, inside: { key: /[a-zA-Z0-9]+(?=\.)/, dot: /\./, val: /^[^.][a-zA-Z0-9]+/ } }, punctuation: r } }, { pattern: /(spx-component)=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, lookbehind: true, global: true, inside: { "component-name": /[a-zA-Z0-9-]+/, separator: /[|,]/, punctuation: r } }, { pattern: /(spx-bind)=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, lookbehind: true, global: true, inside: { "bind-notation": { pattern: /[a-zA-Z0-9]+\.[a-zA-Z0-9]+/, inside: { "event-key": /[a-zA-Z0-9]+(?=\.)/, dot: /\./, val: /^[^.][a-zA-Z0-9]+/ } }, punctuation: r } }, { pattern: /(spx@[a-z]+)=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, lookbehind: true, global: true, inside: { "dot-notation": { pattern: /[a-zA-Z0-9]+\.[a-zA-Z0-9]+/, inside: { "event-key": /[a-zA-Z0-9]+(?=\.)/, dot: /\./, val: /^[^.][a-zA-Z0-9]+/ } }, punctuation: r } }], "attr-value": { pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, inside: { number: { pattern: /(["'])[0-9]+\.[0-9]+(?=['"])/, lookbehind: true }, integer: { pattern: /(["'])[0-9]+(?=['"])/, lookbehind: true }, boolean: /\b(true|false)\b/, script: { pattern: /[[{][\s\S]*?[\]}]/, greedy: true, inside: P2.default.languages.javascript }, punctuation: [{ pattern: /^=/, alias: "attr-equals" }, { pattern: /^(\s*)["']|["']$/, lookbehind: true }] } }, punctuation: /\/?>/, "attr-name": { pattern: /[^\s>/]+/, inside: { "spx-name": { pattern: /(spx-target|spx-morph|spx-replace|spx-hover|spx-eval|spx-data|spx-component|spx-node|spx-bind|spx-watch|spx-hydrate|spx-intersect|spx-prepend|spx-append|spx-threshold|spx-proximity|spx-position|spx-progress|spx-scroll|spx-cache|spx-disable|spx-history)\b/ }, "ns-notation": { pattern: /[a-zA-Z0-9-]+:[a-zA-Z0-9-]+$/, inside: { prefix: /^[\w-]+?(?=:)/, symbol: /:/, suffix: /[a-zA-Z0-9-]+?$/ } }, "at-notation": { pattern: /[a-zA-Z0-9]+@[a-zA-Z0-9]+$/, inside: { prefix: /^[\w-]+?(?=@)/, symbol: /@/, suffix: /[a-zA-Z0-9]+?$/ } }, namespace: /^[^\s>/:]+:/ } } } }, entity: [{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\da-f]{1,8};/i] }, P2.default.languages.markup.tag.inside["attr-value"].inside.entity = P2.default.languages.markup.entity, P2.default.languages.markup.doctype.inside["internal-subset"].inside = P2.default.languages.markup, P2.default.hooks.add("wrap", function(e2) {
      e2.type === "entity" && (e2.attributes.title = e2.content.replace(/&amp;/, "&"));
    }), Object.defineProperty(P2.default.languages.markup.tag, "addInlined", { value: function(t, i2) {
      let n = {};
      n["language-" + i2] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: true, inside: P2.default.languages[i2] }, n.cdata = /^<!\[CDATA\[|\]\]>$/i;
      let a2 = { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: n } };
      a2["language-" + i2] = { pattern: /[\s\S]+/, inside: P2.default.languages[i2] };
      let o2 = {};
      o2[t] = { pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
        return t;
      }), "i"), lookbehind: true, greedy: true, inside: a2 }, P2.default.languages.insertBefore("markup", "cdata", o2);
    } }), Object.defineProperty(P2.default.languages.markup.tag, "addAttribute", { value: function(e2, t) {
      P2.default.languages.markup.tag.inside["special-attr"].push({ pattern: RegExp(/(^|["'\s])/.source + "(?:" + e2 + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"), lookbehind: true, inside: { "attr-name": /^[^\s=]+/, "attr-value": { pattern: /=[\s\S]+/, inside: { value: { pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/, lookbehind: true, alias: [t, "language-" + t], inside: P2.default.languages[t] }, punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/] } } } });
    } }), P2.default.languages.html = P2.default.languages.markup, P2.default.languages.mathml = P2.default.languages.markup, P2.default.languages.svg = P2.default.languages.markup, P2.default.languages.xml = P2.default.languages.extend("markup", {}), P2.default.languages.ssml = P2.default.languages.xml, P2.default.languages.atom = P2.default.languages.xml, P2.default.languages.rss = P2.default.languages.xml, P2.default.languages.html;
  }
  var D2 = W(K());
  function _t() {
    let r = { "tag-name": { lookbehind: true, pattern: /({%-?\s*)([a-z_$][\w$]+)/ }, output: { lookbehind: true, pattern: /({{-?\s*)([a-z_$][\w$]+)/ }, delimiters: { pattern: /{%|{{|}}|%}/ }, object: { lookbehind: true, pattern: /\b[a-z_$]+(?=\.\s*)/i }, property: { lookbehind: true, pattern: /(\.\s*)[a-z_$][\w$]+(?=[.\s])/i }, filter: { lookbehind: true, pattern: /(\|)\s*(\w+)(?=[:]?)/ }, string: { lookbehind: true, pattern: /['"].*?['"]/ }, punctuation: { global: true, lookbehind: true, pattern: /[.,|:?]/ }, operator: { pattern: /[!=]=|<|>|[<>]=?|[|?:=-]|\b(?:in|and|contains(?=\s)|or)\b/ }, array: { lookbehind: true, pattern: /(\s+in\s+)(\b[a-z_$][\w$]+)(?=\.\s*)/ }, boolean: { pattern: /\b(?:true|false|nil)\b/ }, number: { pattern: /\b(?:\d+)\b/ }, parameter: { lookbehind: true, global: true, greedy: true, pattern: /([,:])\s*(\w+)(?=:)/i } }, e2 = { comment: { global: true, pattern: /(\{%-?\s*comment\s*-?%\}[\s\S]+\{%-?\s*endcomment\s*-?%\}|\{%-?\s*#[\s\S]+?-?%\})/ }, liquid: { pattern: /({{|{%)[\s\S]+(}}|%})/, global: true, inside: r } };
    return D2.default.languages.insertBefore("css", "property", { liquid: { pattern: /{[{%][\s\S]+[%}]}/, inside: r } }), D2.default.languages.liquid = D2.default.languages.extend("markup", e2), D2.default.languages.liquid.tag.alias = "markup", D2.default.languages.liquid.tag.inside["attr-value"].inside.liquid = { alias: "liquid-string", pattern: /{[{%]-?[\s\S]+-?[%}]}/, inside: e2 }, D2.default.languages.liquid.tag.inside["special-attr"].push({ pattern: /{%(?!\d)[^\s]*(?:(?:"[^"]*"|'[^']*'|[^\s'"])|(?!{%)|[^%]*}|[^}])*?%}/, inside: r }), delete D2.default.languages.liquid.tag.inside["attr-value"].inside.number, delete D2.default.languages.liquid.tag.inside["attr-value"].inside.boolean, delete D2.default.languages.liquid.tag.inside["attr-value"].inside.script, delete D2.default.languages.liquid.tag.inside["attr-value"].inside["dot-notation"], D2.default.languages.liquid["language-css"] = { inside: D2.default.languages.css, lookbehind: true, pattern: /(\{%-?\s*style(?:sheet)?\s*-?%\})([\s\S]+?)(?=\{%-?\s*endstyle(?:sheet)?\s*-?%\})/ }, D2.default.languages.liquid["language-javascript"] = { inside: D2.default.languages.javascript, lookbehind: true, pattern: /(\{%-?\s*javascript\s*-?%\})([\s\S]*?)(?=\{%-?\s*endjavascript\s*-?%\})/ }, D2.default.languages.liquid["language-json"] = { inside: D2.default.languages.json, lookbehind: true, pattern: /(\{%-?\s*schema\s*-?%\})([\s\S]+?)(?=\{%-?\s*endschema\s*-?%\})/ }, Object.defineProperty(D2.default.languages.liquid.tag, "addInlined", { value: function(i2, n) {
      let a2 = {};
      a2["language-" + n] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: true, inside: D2.default.languages[n] }, a2.cdata = /^<!\[CDATA\[|\]\]>$/i;
      let o2 = { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: a2 } };
      o2["language-" + n] = { pattern: /[\s\S]+/, inside: D2.default.languages[n] };
      let b2 = {};
      b2[i2] = { pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
        return i2;
      }), "i"), lookbehind: true, greedy: true, inside: o2 }, D2.default.languages.insertBefore("liquid", "cdata", b2);
    } }), D2.default.languages.liquid;
  }
  var Y = W(K());
  function Tt() {
    Y.default.languages.typescript = Y.default.languages.extend("javascript", { "class-name": { pattern: /(\b(?:extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/, lookbehind: true, greedy: true, inside: null }, builtin: { pattern: /(\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b\s+)/, global: true } }), Y.default.languages.typescript.keyword.push(/\b(?:abstract|declare|is|keyof|readonly|require|static)\b/, /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/, /\btype\b(?=\s*(?:[{*]|$))/), delete Y.default.languages.typescript.parameter, delete Y.default.languages.typescript["literal-property"];
    let r = Y.default.languages.extend("typescript", {});
    return delete r["class-name"], Y.default.languages.typescript["class-name"].inside = r, Y.default.languages.insertBefore("typescript", "function", { decorator: { pattern: /@[$\w\xA0-\uFFFF]+/, inside: { at: { pattern: /^@/, alias: "operator" }, function: /^[\s\S]+/ } }, "generic-function": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/, greedy: true, inside: { function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/, generic: { pattern: /<[\s\S]+/, alias: "types", inside: r } } }, parameter: [{ pattern: /(\s*[a-z_$]*?\s*\()\s*[a-z_$][\w$]+(?=\?:\s*)/i, lookbehind: true, global: true, alias: "optional" }, { pattern: /(\s*[a-z_$]*?\s*\()\s*[a-z_$][\w$]+(?=:\s*)/i, lookbehind: true, global: true }, { pattern: /([a-z_$]*?\??:\s+)\b(?:any|boolean|never|number|string|symbol|unknown)\b\s*(?=[),|])/i, lookbehind: true, global: true, greedy: true, alias: "builtin" }, { pattern: /(\s*[a-z_$]*?\s*\(.*?,\s+)[a-z_$][\w$]+(?=\??:)/i, lookbehind: true, greedy: true }] }), Y.default.languages.ts = Y.default.languages.typescript, Y.default.languages.typescript = Y.default.languages.extend("javascript", { "punctuation-chars": { pattern: /[.,]/, global: true }, semi: { pattern: /[;]/, global: true }, nil: { pattern: /\b(?:null|undefined)\b/ }, "browser-objects": { pattern: /\b(?:window|document|console)\b/ }, types: [{ pattern: /\b(?:any|boolean|console|never|number|string|symbol|unknown|Promise)\b/, global: true, lookbehind: true }], "type-array": { pattern: /\[\]/, global: true }, "type-object": { pattern: /\{\}/, global: true }, "return-type": { pattern: /(\)):(?=\s)/, global: true, lookbehind: true }, flow: { pattern: /\b(?:return|await)\b/ }, method: { pattern: /(\.\s*)[a-z_$][\w$]*(?=(\())/i, lookbehind: true } }), Y.default.languages.typescript;
  }
  var le = W(K());
  function Ft() {
    if (le.default.languages.javascript.keyword = [{ pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|export|from(?=\s*(?:['"]|$))|import)\b/, lookbehind: true, alias: "module" }, { pattern: /(\b(?:class)\b\s+)/, alias: "class" }, { pattern: /((?:^|\})\s*)catch\b/, lookbehind: true, alias: "control-flow" }, { pattern: /(^|[^.]|\.\.\.\s*)\b(?:await|break|case|continue|default|do|else|finally(?=\s*(?:\{|$))|for|if|return|switch|throw|try|while|yield|import|as|export|from|default)\b/, lookbehind: true, alias: "control-flow" }, { pattern: /(^|[^.]|\.\.\.\s*)\b(?:async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|const|debugger|delete|enum|extends|function|(?:get|set)(?=\s*(?:[#[$\w\xA0-\uFFFF]|$))|implements|in|instanceof|interface|let|new|null|of|package|private|protected|public|super|this|typeof\s+|undefined|var|void|with)\b/, lookbehind: true, inside: { this: /\b(this)\b/ } }, { pattern: /(\s+)(\b(?:Boolean|String|Number|Object|Array)\b)/, alias: "type-constructors" }], le.default.languages.insertBefore("javascript", "keyword", { variable: { pattern: /\b(?:const|var|let)\b/ }, "function-name": { pattern: /\b(?:function)\b/ }, property: { lookbehind: true, pattern: /(?:import|as|export|from|default)(?=[:])/ }, operation: { pattern: /(\b(?:typeof|new|of|delete|void|readonly)\b\s+)/, global: true }, object: { lookbehind: true, pattern: /(\s+)\b([a-z_$][\w$]*)(?=[.])/i, global: true, greedy: true, inside: { this: /\b(this)\b/ } }, "punctuation-chars": { pattern: /[.,]/, global: true }, semi: { pattern: /[;]/, global: true }, nil: { pattern: /\b(?:null|undefined)\b/ }, "browser-objects": { pattern: /\b(?:window|document|console)\b/ }, flow: { pattern: /(\b(?:return|await|new)\b\s+)/ }, numeric: { pattern: /(\+{2}|-{2})\w+/, lookbehind: true, inside: { this: /\b(this)\b/ } }, bracket: { pattern: /(\w+)\[.*?\]/, lookbehind: true, inside: { keyword: { pattern: /\w+/ }, punctuation: { pattern: /\[|\]/ } } } }), le.default.languages.html) {
      let r = /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source;
      le.default.languages.html.tag.addInlined("script", "javascript"), le.default.languages.liquid.tag.addInlined("script", "javascript"), le.default.languages.html.tag.addAttribute(r, "javascript");
    }
    return le.default.languages.javascript;
  }
  var Pe = W(K());
  function Lt() {
    return Pe.default.languages.xml = Pe.default.languages.extend("markup", { tag: { pattern: /<\/?(?!\d)[^\s>/=$<%]+(?:\s(?:\s*[^\s>/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/, greedy: true, inside: { tag: { pattern: /^<\/?[^\s>/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>/:]+(?=:)/, prefix: /:/ } }, "special-attr": [], "attr-value": { pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, inside: { punctuation: [{ pattern: /^=/, alias: "attr-equals" }] } }, punctuation: /\/?>/, "attr-name": { pattern: /[^\s>/]+/, inside: { namespace: /^[^\s>/:]+:/ } } } } }), Pe.default.languages.xml;
  }
  var et = W(K());
  function kt() {
    let r = /[*&][^\s[\]{},]+/, e2 = r.source, t = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/, i2 = "(?:" + t.source + "(?:[ 	]+" + e2 + ")?|" + e2 + "(?:[ 	]+" + t.source + ")?)", n = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
      return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
    }), a2 = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
    function o2(b2, s2) {
      s2 = (s2 || "").replace(/m/g, "") + "m";
      let { source: S2 } = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/, E = S2.replace(/<<prop>>/g, i2).replace(/<<value>>/g, b2);
      return RegExp(E, s2);
    }
    return et.default.languages.yaml = { scalar: { pattern: RegExp(/([-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, i2)), lookbehind: true, alias: "string" }, comment: /#.*/, key: { pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, i2).replace(/<<key>>/g, "(?:" + n + "|" + a2 + ")")), lookbehind: true, greedy: true }, directive: { pattern: /(^[ \t]*)%.+/m, lookbehind: true, alias: "important" }, datetime: { pattern: o2(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source), lookbehind: true, alias: "number" }, boolean: { pattern: o2(/false|true/.source, "i"), lookbehind: true, alias: "important" }, null: { pattern: o2(/null|~/.source, "i"), lookbehind: true, alias: "important" }, string: { pattern: o2(a2), lookbehind: true, greedy: true }, number: { pattern: o2(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"), lookbehind: true }, tag: t, important: r, punctuation: /---|[:[\]{}\-,|>?]|\.\.\./ }, et.default.languages.yaml;
  }
  var ue = W(K());
  function $t() {
    let r = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, e2 = { "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/, "pseudo-class": /:[-\w]+/, class: /\.[-\w]+/, id: /#[-\w]+/, "css-tag": /\w+/, attribute: { pattern: RegExp(`\\[(?:[^[\\]"']|` + r.source + ")*\\]"), greedy: true, inside: { punctuation: /^\[|\]$/, "case-sensitivity": { pattern: /(\s)[si]$/i, lookbehind: true, alias: "keyword" }, namespace: { pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/, lookbehind: true, inside: { punctuation: /\|$/ } }, "css-attr-name": { pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/, lookbehind: true }, "css-attr-value": [r, { pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/, lookbehind: true }], operator: /[|~*^$]?=/ } }, "n-th": [{ pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/, lookbehind: true, inside: { number: /[\dn]+/, operator: /[+-]/ } }, { pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i, lookbehind: true }], combinator: />|\+|~|\|\|/, punctuation: /[(),]/ };
    ue.default.languages.css.selector = { pattern: ue.default.languages.css.selector.pattern, lookbehind: true, inside: e2 }, ue.default.languages.css.atrule.inside["selector-function-argument"].inside = e2, ue.default.languages.insertBefore("css", "punctuation", { colon: /:/ }), ue.default.languages.insertBefore("css", "property", { variable: { pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i, lookbehind: true }, "property-value": { lookbehind: true, pattern: /([: ])([a-z-]+)(?=;)/ } });
    let t = { pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/, lookbehind: true }, i2 = { pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/, lookbehind: true };
    return ue.default.languages.insertBefore("css", "function", { operator: { pattern: /(\s)[+\-*/](?=\s)/, lookbehind: true }, hexcode: { pattern: /\B#[\da-f]{3,8}\b/i, alias: "color" }, color: [{ pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i, inside: { unit: t, number: i2, function: /[\w-]+(?=\()/, punctuation: /[(),]/ } }], entity: /\\[\da-f]{1,8}/i, unit: t, number: i2 }), ue.default.languages.css;
  }
  var ie = W(K());
  function Ot() {
    return ie.default.languages.scss = ie.default.languages.extend("css", { comment: { pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/, lookbehind: true }, atrule: { pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/, inside: { rule: /@[\w-]+/ } }, url: /(?:[-a-z]+-)?url(?=\()/i, selector: { pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/, inside: { parent: { pattern: /&/, alias: "important" }, placeholder: /%[-\w]+/, variable: /\$[-\w]+|#\{\$[-\w]+\}/ } }, property: { pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/, inside: { variable: /\$[-\w]+|#\{\$[-\w]+\}/ } } }), ie.default.languages.insertBefore("scss", "atrule", { keyword: [/@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i, { pattern: /( )(?:from|through)(?= )/, lookbehind: true }] }), ie.default.languages.insertBefore("scss", "important", { variable: /\$[-\w]+|#\{\$[-\w]+\}/ }), ie.default.languages.insertBefore("scss", "function", { "module-modifier": { pattern: /\b(?:as|hide|show|with)\b/i, alias: "keyword" }, placeholder: { pattern: /%[-\w]+/, alias: "selector" }, statement: { pattern: /\B!(?:default|optional)\b/i, alias: "keyword" }, boolean: /\b(?:false|true)\b/, null: { pattern: /\bnull\b/, alias: "keyword" }, operator: { pattern: /(\s)(?:[-+*/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/, lookbehind: true } }), ie.default.languages.scss.atrule.inside.rest = ie.default.languages.scss, ie.default.languages.scss;
  }
  var tt = W(K());
  function Pt() {
    return tt.default.languages.json = { property: { pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/, lookbehind: true, greedy: true }, string: { pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/, lookbehind: true, greedy: true }, comment: { pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: true }, number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i, punctuation: /[{}[\],]/, operator: /:/, boolean: /\b(?:false|true|null)\b/ }, tt.default.languages.json;
  }
  var nt = W(K());
  function Nt() {
    return nt.default.languages.bash = { argument: { pattern: /<(.*?)>/ }, punctuation: { pattern: /\$|&{2}|[<>]|--?(?=[a-z])/ }, comment: { pattern: /#.*?(?=\n)/ } }, nt.default.languages.bash;
  }
  var rt = W(K());
  function It() {
    rt.default.languages.treeview = { comment: { pattern: /#.*/ }, "treeview-part": { pattern: /^.+/m, inside: { "entry-line": [{ pattern: /\|-- | /, alias: "line-h" }, { pattern: /\| {3}| {3}/, alias: "line-v" }, { pattern: /`-- | /, alias: "line-v-last" }, { pattern: / {4}/, alias: "line-v-gap" }], "entry-name": { pattern: /.*\S.*/, inside: { operator: / -> / } } } } }, rt.default.hooks.add("wrap", function(r) {
      if (r.language === "treeview" && r.type === "entry-name") {
        let e2 = r.classes, t = /(^|[^\\])\/\s*$/;
        if (t.test(r.content))
          r.content = r.content.replace(t, "$1"), e2.push("dir");
        else {
          r.content = r.content.replace(/(^|[^\\])[=*|]\s*$/, "$1");
          let i2 = r.content.toLowerCase().replace(/\s+/g, "").split(".");
          for (; i2.length > 1; )
            i2.shift(), e2.push("ext-" + i2.join("-"));
        }
        r.content[0] === "." && e2.push("dotfile");
      }
    });
  }
  function it() {
    if (!Ne.default.papyrus) {
      for (let r of [Ct, _t, Ft, Tt, Lt, $t, Ot, kt, Pt, Nt, It])
        r();
      Ne.default.papyrus = true;
    }
    return Ne.default;
  }
  var at = W(K());
  function we(r, e2) {
    if (e2.showLF === false && e2.showCR === false && e2.showSpace === false && e2.showCRLF === false && e2.showTab === false)
      return;
    let t = { tab: /\t/ };
    e2.showTab && (t.tab = /\t/), e2.showCR && (t.cr = /\r/), e2.showLF && (t.lf = /\n/), e2.showSpace && (t.space = / /), e2.showCRLF && (t.crlf = /\r\n/);
    function i2(a2, o2) {
      let b2 = a2[o2];
      switch (at.default.util.type(b2)) {
        case "RegExp":
          var S2 = {};
          a2[o2] = { pattern: b2, inside: S2 }, n(S2);
          break;
        case "Array":
          for (let E = 0, c = b2.length; E < c; E++)
            i2(b2, E);
          break;
        default:
          var S2 = b2.inside || (b2.inside = {});
          n(S2);
          break;
      }
    }
    function n(a2) {
      if (!(!a2 || a2.tab)) {
        for (let o2 in t)
          o2 in t ? a2[o2] = t[o2] : o2 in a2 && delete a2[o2];
        for (let o2 in a2)
          o2 in a2 && !t[o2] && (o2 === "rest" ? n(a2.rest) : i2(a2, o2));
      }
    }
    n(at.default.languages[r]);
  }
  var En = Object.assign || ((r, e2) => (e2 && Object.keys(e2).forEach((t) => r[t] = e2[t]), r));
  var st = (r, e2, t) => {
    let i2 = typeof t;
    if (t && i2 === "object")
      if (Array.isArray(t))
        for (let n of t)
          e2 = st(r, e2, n);
      else
        for (let n of Object.keys(t)) {
          let a2 = t[n];
          typeof a2 == "function" ? e2[n] = a2(e2[n], Ie) : a2 === void 0 ? r && !isNaN(n) ? e2.splice(n, 1) : delete e2[n] : a2 === null || typeof a2 != "object" || Array.isArray(a2) ? e2[n] = a2 : typeof e2[n] == "object" ? e2[n] = a2 === e2[n] ? a2 : Ie(e2[n], a2) : e2[n] = st(false, {}, a2);
        }
    else
      i2 === "function" && (e2 = t(e2, Ie));
    return e2;
  };
  var Ie = (r, ...e2) => {
    let t = Array.isArray(r);
    return st(t, t ? r.slice() : En({}, r), e2);
  };
  var Se = Ie;
  function Ce(r, e2) {
    return r in e2;
  }
  function ce(r, e2) {
    return e2.trimStart && e2.trimEnd ? r.trim() : e2.trimStart === true && e2.trimEnd === false ? r.trimStart() : e2.trimStart === false && e2.trimEnd === true ? r.trimEnd() : r;
  }
  function Dt(r) {
    if (r === null)
      return null;
    let e2 = { html: "html", shell: "bash", bash: "bash", cli: "bash", css: "css", scss: "scss", liquid: "liquid", xml: "xml", json: "json", javascript: "javascript", js: "javascript", typescript: "typescript", ts: "typescript", jsx: "jsx", tsx: "tsx", yaml: "yaml", yml: "yaml", plaintext: "plaintext", treeview: "treeview", tree: "treeview" };
    return r in e2 ? e2[r] : (console.error(`\u{13041} Papyprus: Unsupported language "${r}" provided, will fallback to "plaintext"`), null);
  }
  function ne(r) {
    return r.split(`
`).length;
  }
  function De(r, e2 = 0) {
    if (isNaN(r))
      return "";
    e2 = e2 - 1;
    let t = "", i2 = 0;
    for (; i2 < r; i2++)
      e2 === i2 ? t += '<span class="ln highlight"></span>' : t += '<span class="ln"></span>';
    return `<div class="line-numbers">${t}</div>`;
  }
  function An(r) {
    if ("autoClosingPairs" in r)
      for (let [e2, t] of r.autoClosingPairs) {
        if (e2.length !== 1)
          throw new Error(`\u{13041} Papyprus: Invalid "autoClosePairs" character ("${e2}") - Single characters only!`);
        if (e2.length !== 1)
          throw new Error(`\u{13041} Papyprus: Invalid "autoClosePairs" character ("${t}") - Single characters only!`);
      }
    if ("autoIndentPairs" in r)
      for (let [e2, t] of r.autoIndentPairs) {
        if (e2.length !== 1)
          throw new Error(`\u{13041} Papyprus: Invalid "autoIndentPairs" character ("${e2}") - Single characters only!`);
        if (e2.length !== 1)
          throw new Error(`\u{13041} Papyprus: Invalid "autoIndentPairs" character ("${t}") - Single characters only!`);
      }
  }
  function _e(r, e2 = { autoClosingPairs: [['"', '"'], ["(", ")"], ["{", "}"], ["[", "]"]], autoIndentPairs: [["{", "}"], ["[", "]"]], indentChar: " ", indentSize: 2, lineHighlight: true, lineIndent: true, lineNumber: 1, locLimit: 1500, renderSpace: false, renderTab: false, spellcheck: false, tabConvert: true, tabIndent: true, completions: {} }) {
    if (r === true)
      return e2;
    let t = Se(e2, r);
    return An(t), t;
  }
  function xe(r) {
    let e2 = Se({ id: null, language: null, input: "", lineFence: true, lineNumbers: true, showCRLF: false, showSpace: false, showCR: false, showLF: false, showTab: false, trimEnd: true, trimStart: true, editor: false, startMode: "static", addAttrs: { pre: [], code: [] }, addClass: { pre: [], code: [] } }, r);
    return e2.editor !== false && (e2.editor = _e(e2.editor), e2.startMode = "editor"), e2.language === "treeview" && (e2.lineNumbers = false, e2.editor = false, e2.showSpace = false, e2.showSpace = false, e2.showCR = false, e2.showLF = false, e2.showTab = false, e2.startMode = "static"), e2;
  }
  function Mt() {
    return Math.random().toString(36).slice(2);
  }
  function Rt(r) {
    return r === "" ? document.execCommand("delete") : document.execCommand("insertText", false, r);
  }
  function jt(r, e2) {
    let t = r.lastIndexOf(`
`, e2 - 1) + 1;
    return r.charAt(t) !== "	" ? e2 : t + 1;
  }
  var zt = 11;
  function Sn(r, e2) {
    var t = e2.attributes, i2, n, a2, o2, b2;
    if (!(e2.nodeType === zt || r.nodeType === zt)) {
      for (var s2 = t.length - 1; s2 >= 0; s2--)
        i2 = t[s2], n = i2.name, a2 = i2.namespaceURI, o2 = i2.value, a2 ? (n = i2.localName || n, b2 = r.getAttributeNS(a2, n), b2 !== o2 && (i2.prefix === "xmlns" && (n = i2.name), r.setAttributeNS(a2, n, o2))) : (b2 = r.getAttribute(n), b2 !== o2 && r.setAttribute(n, o2));
      for (var S2 = r.attributes, E = S2.length - 1; E >= 0; E--)
        i2 = S2[E], n = i2.name, a2 = i2.namespaceURI, a2 ? (n = i2.localName || n, e2.hasAttributeNS(a2, n) || r.removeAttributeNS(a2, n)) : e2.hasAttribute(n) || r.removeAttribute(n);
    }
  }
  var Me;
  var Cn = "http://www.w3.org/1999/xhtml";
  var J = typeof document == "undefined" ? void 0 : document;
  var _n = !!J && "content" in J.createElement("template");
  var Tn = !!J && J.createRange && "createContextualFragment" in J.createRange();
  function Fn(r) {
    var e2 = J.createElement("template");
    return e2.innerHTML = r, e2.content.childNodes[0];
  }
  function Ln(r) {
    Me || (Me = J.createRange(), Me.selectNode(J.body));
    var e2 = Me.createContextualFragment(r);
    return e2.childNodes[0];
  }
  function kn(r) {
    var e2 = J.createElement("body");
    return e2.innerHTML = r, e2.childNodes[0];
  }
  function $n(r) {
    return r = r.trim(), _n ? Fn(r) : Tn ? Ln(r) : kn(r);
  }
  function Re(r, e2) {
    var t = r.nodeName, i2 = e2.nodeName, n, a2;
    return t === i2 ? true : (n = t.charCodeAt(0), a2 = i2.charCodeAt(0), n <= 90 && a2 >= 97 ? t === i2.toUpperCase() : a2 <= 90 && n >= 97 ? i2 === t.toUpperCase() : false);
  }
  function On(r, e2) {
    return !e2 || e2 === Cn ? J.createElement(r) : J.createElementNS(e2, r);
  }
  function Pn(r, e2) {
    for (var t = r.firstChild; t; ) {
      var i2 = t.nextSibling;
      e2.appendChild(t), t = i2;
    }
    return e2;
  }
  function ot(r, e2, t) {
    r[t] !== e2[t] && (r[t] = e2[t], r[t] ? r.setAttribute(t, "") : r.removeAttribute(t));
  }
  var Ht = { OPTION: function(r, e2) {
    var t = r.parentNode;
    if (t) {
      var i2 = t.nodeName.toUpperCase();
      i2 === "OPTGROUP" && (t = t.parentNode, i2 = t && t.nodeName.toUpperCase()), i2 === "SELECT" && !t.hasAttribute("multiple") && (r.hasAttribute("selected") && !e2.selected && (r.setAttribute("selected", "selected"), r.removeAttribute("selected")), t.selectedIndex = -1);
    }
    ot(r, e2, "selected");
  }, INPUT: function(r, e2) {
    ot(r, e2, "checked"), ot(r, e2, "disabled"), r.value !== e2.value && (r.value = e2.value), e2.hasAttribute("value") || r.removeAttribute("value");
  }, TEXTAREA: function(r, e2) {
    var t = e2.value;
    r.value !== t && (r.value = t);
    var i2 = r.firstChild;
    if (i2) {
      var n = i2.nodeValue;
      if (n == t || !t && n == r.placeholder)
        return;
      i2.nodeValue = t;
    }
  }, SELECT: function(r, e2) {
    if (!e2.hasAttribute("multiple")) {
      for (var t = -1, i2 = 0, n = r.firstChild, a2, o2; n; )
        if (o2 = n.nodeName && n.nodeName.toUpperCase(), o2 === "OPTGROUP")
          a2 = n, n = a2.firstChild;
        else {
          if (o2 === "OPTION") {
            if (n.hasAttribute("selected")) {
              t = i2;
              break;
            }
            i2++;
          }
          n = n.nextSibling, !n && a2 && (n = a2.nextSibling, a2 = null);
        }
      r.selectedIndex = t;
    }
  } };
  var Te = 1;
  var qt = 11;
  var Ut = 3;
  var Bt = 8;
  function de() {
  }
  function Nn(r) {
    if (r)
      return r.getAttribute && r.getAttribute("id") || r.id;
  }
  function In(r) {
    return function(t, i2, n) {
      if (n || (n = {}), typeof i2 == "string")
        if (t.nodeName === "#document" || t.nodeName === "HTML" || t.nodeName === "BODY") {
          var a2 = i2;
          i2 = J.createElement("html"), i2.innerHTML = a2;
        } else
          i2 = $n(i2);
      else
        i2.nodeType === qt && (i2 = i2.firstElementChild);
      var o2 = n.getNodeKey || Nn, b2 = n.onBeforeNodeAdded || de, s2 = n.onNodeAdded || de, S2 = n.onBeforeElUpdated || de, E = n.onElUpdated || de, c = n.onBeforeNodeDiscarded || de, F2 = n.onNodeDiscarded || de, x2 = n.onBeforeElChildrenUpdated || de, v2 = n.skipFromChildren || de, u2 = n.addChild || function(C2, T2) {
        return C2.appendChild(T2);
      }, l2 = n.childrenOnly === true, d2 = /* @__PURE__ */ Object.create(null), g3 = [];
      function f2(C2) {
        g3.push(C2);
      }
      function A(C2, T2) {
        if (C2.nodeType === Te)
          for (var $3 = C2.firstChild; $3; ) {
            var L2 = void 0;
            T2 && (L2 = o2($3)) ? f2(L2) : (F2($3), $3.firstChild && A($3, T2)), $3 = $3.nextSibling;
          }
      }
      function k2(C2, T2, $3) {
        c(C2) !== false && (T2 && T2.removeChild(C2), F2(C2), A(C2, $3));
      }
      function w2(C2) {
        if (C2.nodeType === Te || C2.nodeType === qt)
          for (var T2 = C2.firstChild; T2; ) {
            var $3 = o2(T2);
            $3 && (d2[$3] = T2), w2(T2), T2 = T2.nextSibling;
          }
      }
      w2(t);
      function N2(C2) {
        s2(C2);
        for (var T2 = C2.firstChild; T2; ) {
          var $3 = T2.nextSibling, L2 = o2(T2);
          if (L2) {
            var O = d2[L2];
            O && Re(T2, O) ? (T2.parentNode.replaceChild(O, T2), G(O, T2)) : N2(T2);
          } else
            N2(T2);
          T2 = $3;
        }
      }
      function R2(C2, T2, $3) {
        for (; T2; ) {
          var L2 = T2.nextSibling;
          ($3 = o2(T2)) ? f2($3) : k2(T2, C2, true), T2 = L2;
        }
      }
      function G(C2, T2, $3) {
        var L2 = o2(T2);
        L2 && delete d2[L2], !(!$3 && (S2(C2, T2) === false || (r(C2, T2), E(C2), x2(C2, T2) === false))) && (C2.nodeName !== "TEXTAREA" ? te(C2, T2) : Ht.TEXTAREA(C2, T2));
      }
      function te(C2, T2) {
        var $3 = v2(C2, T2), L2 = T2.firstChild, O = C2.firstChild, Q, B, V, p3, h3;
        e:
          for (; L2; ) {
            for (p3 = L2.nextSibling, Q = o2(L2); !$3 && O; ) {
              if (V = O.nextSibling, L2.isSameNode && L2.isSameNode(O)) {
                L2 = p3, O = V;
                continue e;
              }
              B = o2(O);
              var m2 = O.nodeType, _ = void 0;
              if (m2 === L2.nodeType && (m2 === Te ? (Q ? Q !== B && ((h3 = d2[Q]) ? V === h3 ? _ = false : (C2.insertBefore(h3, O), B ? f2(B) : k2(O, C2, true), O = h3, B = o2(O)) : _ = false) : B && (_ = false), _ = _ !== false && Re(O, L2), _ && G(O, L2)) : (m2 === Ut || m2 == Bt) && (_ = true, O.nodeValue !== L2.nodeValue && (O.nodeValue = L2.nodeValue))), _) {
                L2 = p3, O = V;
                continue e;
              }
              B ? f2(B) : k2(O, C2, true), O = V;
            }
            if (Q && (h3 = d2[Q]) && Re(h3, L2))
              $3 || u2(C2, h3), G(h3, L2);
            else {
              var I2 = b2(L2);
              I2 !== false && (I2 && (L2 = I2), L2.actualize && (L2 = L2.actualize(C2.ownerDocument || J)), u2(C2, L2), N2(L2));
            }
            L2 = p3, O = V;
          }
        R2(C2, O, B);
        var H = Ht[C2.nodeName];
        H && H(C2, T2);
      }
      var M2 = t, se = M2.nodeType, be = i2.nodeType;
      if (!l2) {
        if (se === Te)
          be === Te ? Re(t, i2) || (F2(t), M2 = Pn(t, On(i2.nodeName, i2.namespaceURI))) : M2 = i2;
        else if (se === Ut || se === Bt) {
          if (be === se)
            return M2.nodeValue !== i2.nodeValue && (M2.nodeValue = i2.nodeValue), M2;
          M2 = i2;
        }
      }
      if (M2 === i2)
        F2(t);
      else {
        if (i2.isSameNode && i2.isSameNode(M2))
          return;
        if (G(M2, i2, l2), g3)
          for (var oe = 0, j2 = g3.length; oe < j2; oe++) {
            var q = d2[g3[oe]];
            q && k2(q, q.parentNode, false);
          }
      }
      return !l2 && M2 !== t && t.parentNode && (M2.actualize && (M2 = M2.actualize(t.ownerDocument || J)), t.parentNode.replaceChild(M2, t)), M2;
    };
  }
  var Dn = In(Sn);
  var Wt = Dn;
  function je(r) {
    let e2 = "static", t = r.language, i2, n, a2, o2 = NaN;
    it();
    for (let c in he.default.languages)
      we(c, r);
    function b2(c) {
      if ((t === null || t !== c) && (t = Dt(c)), a2 && a2.hasAttribute("class")) {
        let F2 = a2.className.indexOf("language-");
        if (F2 > 0) {
          let x2 = a2.className.slice(F2 + 9).split(" ")[0].trimEnd();
          x2 !== t && (a2.classList.remove(`language-${x2}`), a2.classList.add(`language-${t}`));
        } else
          a2.classList.add(`language-${t}`);
      }
      return i2 = he.default.languages[t] || he.default.languages.plaintext, t;
    }
    function s2(c) {
      if (c.tagName === "PRE") {
        if (c.firstElementChild !== null && c.firstElementChild.tagName !== "CODE")
          throw new Error('\u{13041} Papyprus: Missing "<code>" element');
        n = c, a2 = c.firstElementChild;
      } else if (c.tagName === "CODE") {
        if (c.parentElement !== null && c.parentElement.tagName !== "PRE")
          throw new Error('\u{13041} Papyprus: The "<pre>" element must be a parent of "<code>"');
        n = c.parentElement, a2 = c;
      } else
        n = document.createElement("pre"), a2 = document.createElement("code"), n.appendChild(a2), c.append(n);
      n.classList.contains("papyrus") || n.classList.add("papyrus"), n.hasAttribute("data-papyrus") === false && (r.startMode === "editor" ? n.setAttribute("data-papyrus", "editor") : n.setAttribute("data-papyrus", "static")), n.hasAttribute("id") || (r.id ? n.id = r.id : n.id = Mt());
    }
    function S2(c) {
      it();
      for (let x2 in he.default.languages)
        we(x2, r);
      let F2 = he.default.highlight(c, i2, t);
      if (r.lineNumbers) {
        let x2 = r.editor;
        return o2 = ne(c), x2.lineHighlight ? `${F2}${De(o2, r.editor.lineNumber)}` : `${F2}${De(o2, 0)}`;
      } else
        return `${F2}`;
    }
    function E(c) {
      let F2 = he.default.highlight(c, i2, t);
      Wt(a2, `<code>${F2}${De(o2)}</code>`, { childrenOnly: true, onBeforeElUpdated: (x2, v2) => !(x2.classList.contains("active") || x2.isEqualNode(v2)) });
    }
    return { get id() {
      return n.id;
    }, get languageId() {
      return t;
    }, get lines() {
      return o2;
    }, set lines(c) {
      o2 = c;
    }, get model() {
      return re;
    }, get code() {
      return a2;
    }, get lineNumbers() {
      return a2.lastElementChild;
    }, get pre() {
      return n;
    }, get mode() {
      return e2;
    }, set mode(c) {
      e2 = c;
    }, raw: S2, highlight: E, nodes: s2, language: b2 };
  }
  var un = W(wt());
  var cn = W(ln());
  function dn(r, e2) {
    let { code: t, pre: i2 } = r, n, a2, o2, b2, s2, S2, E = r.languageId, c = null, F2 = -1, x2 = 0, v2 = ce(t.textContent, e2), u2, l2, d2, g3 = v2, f2 = function(h3) {
      n = h3, S2 = n.indentChar.repeat(n.indentSize + 1), b2 = n.autoClosingPairs.map((m2) => m2[0]), o2 = n.autoIndentPairs.map((m2) => m2[0]), O(), n.lineHighlight && c === null && (c = r.lineNumbers.children[n.lineNumber - 1], c.classList.contains("active") || c.classList.add("active")), s2 || (s2 = document.createElement("textarea")), s2.classList.contains("papyrus-editor") || s2.classList.add("papyrus-editor"), s2.spellcheck = n.spellcheck, s2 && (e2 != null && e2.input && e2.input !== null && e2.input.length > 0 && v2.trim() === "" ? v2 = s2.value = ce(e2.input, e2) : s2.value = v2), a2 && a2.destroy(), E in n.completions && V(n.completions[E]), i2.contains(s2) || i2.appendChild(s2), e2.lineNumbers ? (t.classList.contains("line-numbers") || t.classList.add("line-numbers"), r.lines = ne(v2)) : t.classList.contains("line-numbers") && t.classList.remove("line-numbers"), x2 = s2.scrollTop, s2.onclick = N2, s2.onscroll = w2, s2.oninput = R2, s2.onkeydown = G, r.mode = "editor", i2.getAttribute("data-papyrus") !== "editor" && i2.setAttribute("data-papyrus", "editor"), C2();
    };
    function A() {
      typeof e2.editor == "object" ? f2(e2.editor) : i2.setAttribute("data-papyrus", "static");
    }
    function k2() {
      s2 && s2.remove(), e2.lineNumbers && c.classList.remove("active"), (n.renderSpace !== e2.showSpace || n.renderTab !== e2.showTab) && we(E, e2), r.mode = "static", r.pre.setAttribute("data-papyrus", "static");
    }
    typeof e2.editor == "object" && (f2.enable = A, f2.disable = k2, f2(e2.editor));
    function w2() {
      x2 = s2.scrollTop, s2.scrollTop = x2, t.scrollTop = x2, s2.scrollTop !== t.scrollTop && (s2.scrollTop = t.scrollTop), a2 && a2.isShown() && a2.hide();
      let p3 = t.scrollLeft = s2.scrollLeft;
      p3 > 0 ? p3 > r.lineNumbers.offsetLeft && (c.style.setProperty("width", `${s2.offsetWidth + p3}px`), i2.style.setProperty("--papyrus-fence-offset", `${p3}px`)) : (Ce("--papyrus-fence-offset", i2.style) && i2.style.removeProperty("--papyrus-fence-offset"), c.hasAttribute("style") && c.removeAttribute("style"));
    }
    function N2({ target: p3 }) {
      a2 && a2.isShown() && p3 !== u2 && a2.hide(), te(1);
    }
    function R2() {
      v2 !== s2.value && (v2 = s2.value);
      let p3 = ne(v2);
      n.lineIndent && r.lines < p3 && (s2.scrollTop = x2, t.scrollTop = x2), r.lines = p3, C2(), r.highlight(v2), t.scrollTop !== s2.scrollTop && (t.scrollTop = s2.scrollTop), l2 && l2(v2, E);
    }
    function G(p3) {
      let h3 = p3.key;
      if (h3.startsWith("Arrow"))
        switch (h3) {
          case "ArrowDown":
            te(0);
            break;
          case "ArrowUp":
            te(2);
            break;
          case "ArrowLeft":
          case "ArrowRight":
            te();
            break;
        }
      else if (h3 === "Enter") {
        if (p3.altKey || p3.ctrlKey || a2 && a2.isShown())
          return;
        p3.preventDefault(), v2 = s2.value;
        let m2 = s2.selectionStart, _ = o2.indexOf(v2[m2 - 1]);
        _ > -1 ? T2(m2, _) : L2(`
` + $3()), te(), w2();
      } else if (h3 === "Backspace") {
        v2 = s2.value;
        let m2 = s2.selectionStart - 1;
        if (/\S/.test(v2[m2])) {
          let H = b2.indexOf(v2[m2]);
          if (H > -1) {
            let [ge, ye] = n.autoClosingPairs[H];
            v2[m2] === ge && v2[m2 + 1] === ye && (p3.preventDefault(), s2.setSelectionRange(m2, s2.selectionEnd + 1, "backward"), document.execCommand("delete", false));
          }
          return;
        }
        let _ = v2.lastIndexOf(`
`, m2), I2 = v2.slice(_, m2);
        if (I2.trim() === "" && /[ \t]/.test(v2[m2])) {
          p3.preventDefault();
          let H = s2.selectionStart - n.indentSize;
          s2.setSelectionRange(H, s2.selectionEnd, "backward"), document.execCommand("delete", false), te(), w2();
        }
        I2 === "" && te(2);
      } else if (h3 === "Tab") {
        if (p3.defaultPrevented || p3.metaKey || p3.altKey || p3.ctrlKey)
          return;
        p3.preventDefault(), n.tabIndent && (p3.shiftKey ? B() : Q());
        let m2 = s2.selectionStart, _ = v2.lastIndexOf(`
`, m2 - 1), I2 = v2.slice(_, m2), H = v2.slice(m2, v2.indexOf(`
`, m2)).trimEnd();
        I2.length === 1 && I2.charCodeAt(0) === 10 && H === "" && L2($3()), w2();
      } else if (h3 === "Escape" && !p3.shiftKey)
        a2 && a2.hide(), s2.blur(), p3.preventDefault(), p3.stopImmediatePropagation();
      else if (p3.metaKey && h3 === "s") {
        if (p3.preventDefault(), p3.stopImmediatePropagation(), a2 && a2.hide(), v2 = s2.value, d2) {
          let m2 = d2(v2, E);
          if (typeof m2 == "string") {
            let _ = s2.selectionStart, I2 = s2.selectionEnd;
            s2.select(), L2(m2), s2.selectionStart = _, s2.selectionEnd = I2;
          }
        }
      } else {
        let m2 = b2.indexOf(h3);
        m2 > -1 && s2.value[s2.selectionStart] !== h3 && (p3.preventDefault(), L2(n.autoClosingPairs[m2].join(""), 1));
      }
    }
    function te(p3 = 1) {
      if (a2 && a2.isShown())
        return;
      let m2 = ne(v2.slice(0, s2.selectionStart)) - p3;
      if (F2 !== m2 && (F2 = m2), n.lineHighlight === true && (c && c.classList.contains("active") && (c.classList.remove("active"), c.hasAttribute("style") && c.removeAttribute("style")), c = r.lineNumbers.children[F2], c && c.classList.contains("active") === false)) {
        c.classList.add("active");
        let _ = t.scrollLeft = s2.scrollLeft;
        _ > r.lineNumbers.offsetLeft && c.style.setProperty("width", `${s2.offsetWidth + _}px`);
      }
      C2();
    }
    function M2(p3, h3 = {}) {
      let m2 = Object.assign(h3, { textarea: s2, lineNumber: F2 });
      l2 = p3.bind(m2);
    }
    function se(p3, h3 = {}) {
      let m2 = Object.assign(h3, { textarea: s2, lineNumber: F2 });
      d2 = p3.bind(m2);
    }
    function be(p3, h3, m2) {
      r.mode === "error" && q(), h3 && h3 !== E && h3 !== r.languageId && (O(true), E = r.language(h3), O(false), a2 && (a2.removeAllListeners(), a2.destroy(true)), E in n.completions && (V(n.completions[E]), console.info(`\u{13041} Papyprus: Completions enabled for: ${E}`)), console.info(`\u{13041} Papyprus: Changed Language: ${E}`)), v2 = p3, r.mode !== "static" && (m2 ? s2.value = v2 : (s2.select(), L2(v2))), e2.lineNumbers ? (t.classList.contains("line-numbers") || t.classList.add("line-numbers"), r.lines = ne(v2)) : t.classList.contains("line-numbers") && t.classList.remove("line-numbers"), r.highlight(v2);
    }
    function oe(p3) {
      if (typeof p3 != "object")
        return e2;
      if (p3 != null && p3.lineNumber && (F2 = p3.lineNumber - 1, c = r.lineNumbers.children[F2]), n = _e(p3, n), S2 = n.indentChar.repeat(n.indentSize + 1), b2 = n.autoClosingPairs.map((h3) => h3[0]), o2 = n.autoIndentPairs.map((h3) => h3[0]), s2.spellcheck = n.spellcheck, n.lineHighlight === false) {
        let h3 = r.lineNumbers.querySelector(".active");
        h3 && h3.classList.remove("active");
      }
      return a2 && a2.destroy(), E in n.completions && (V(n.completions[E]), console.info(`\u{13041} Papyprus: Completions enabled for: ${E}`)), n;
    }
    function j2(p3, h3) {
      q(), i2.classList.add("error");
      let m2 = document.createElement("div");
      if (m2.className = "error-message error-ref", m2.innerText = p3, h3) {
        if (h3 != null && h3.title) {
          let _ = document.createElement("div");
          _.className = "error-title error-ref", _.innerText = h3.title, i2.appendChild(_), i2.appendChild(m2);
        } else
          i2.appendChild(m2);
        if (h3 != null && h3.stack) {
          let _ = document.createElement("div");
          _.className = "error-stack error-ref", _.innerText = h3.stack, i2.appendChild(_);
        }
        if (h3 != null && h3.heading) {
          let _ = document.createElement("div");
          _.className = "error-heading error-ref", _.innerText = h3.heading, i2.appendChild(_);
        }
      } else
        i2.appendChild(m2);
      r.mode = "error";
    }
    function q() {
      i2.querySelectorAll(".error-ref").forEach((p3) => p3.remove()), i2.classList.remove("error"), r.mode = s2 ? "editor" : "static";
    }
    return { get initial() {
      return g3;
    }, get textarea() {
      return s2;
    }, get code() {
      return t;
    }, get pre() {
      return i2;
    }, get raw() {
      return v2;
    }, get language() {
      return E;
    }, get mode() {
      return r.mode;
    }, get lines() {
      return r.lines;
    }, get complete() {
      return a2;
    }, showError: j2, hideError: q, onupdate: M2, onsave: se, options: oe, editor: f2, update: be };
    function C2() {
      let p3 = s2.value, h3 = p3.slice(p3.lastIndexOf(`
`, s2.selectionStart - 1) + 1, p3.indexOf(`
`, s2.selectionStart));
      t.ariaLabel = `Ln ${F2 + 1}, Col ${h3.length}`;
    }
    function T2(p3, h3) {
      let m2 = n.autoIndentPairs[h3][1], _ = v2.slice(p3 - 1, v2.indexOf(m2, p3 - 1)), I2 = $3();
      _.indexOf(`
`) > -1 ? L2(`
` + S2 + I2) : v2.slice(p3).trim().charCodeAt(0) === m2.charCodeAt(0) ? L2(`
${S2 + I2}
${I2}`, I2.length + 1) : L2(`
` + I2);
    }
    function $3(p3 = false) {
      let h3 = v2.slice(v2.lastIndexOf(`
`, s2.selectionStart + 1) + 1), m2 = h3.slice(0, h3.search(/[\S\n]/));
      return m2 === "" ? "" : p3 ? m2 + S2 : m2;
    }
    function L2(p3, h3 = NaN) {
      let m2 = s2.ownerDocument, _ = m2.activeElement;
      _ !== s2 && s2.focus(), Rt(p3) || (s2.setRangeText(p3, s2.selectionStart || 0, s2.selectionEnd || 0, "end"), s2.dispatchEvent(new InputEvent("input", { data: p3, inputType: "insertText" }))), _ === m2.body ? s2.blur() : _ instanceof HTMLElement && _ !== s2 && _.focus(), isNaN(h3) || (_ !== s2 && s2.focus(), s2.selectionEnd = s2.selectionEnd - h3), v2 !== s2.value && (v2 = s2.value), C2();
    }
    function O(p3 = false) {
      n && ((n == null ? void 0 : n.renderSpace) !== e2.showSpace || (n == null ? void 0 : n.renderTab) !== e2.showTab) && we(E, p3 ? e2 : Se(e2, { showSpace: n.renderSpace, showTab: n.renderTab }));
    }
    function Q() {
      var H;
      let { selectionStart: p3, selectionEnd: h3, value: m2 } = s2, _ = m2.slice(p3, h3);
      if (((H = /\n/g.exec(_)) == null ? void 0 : H.length) > 0) {
        let ge = m2.lastIndexOf(`
`, p3 - 1) + 1, ye = s2.value.slice(ge, h3 - 1), Ae = ye.replace(/^|\n/g, `$&${n.tabConvert ? S2 : "	"}`), ke = Ae.length - ye.length;
        s2.setSelectionRange(ge, h3 - 1), L2(Ae), s2.setSelectionRange(p3 + 1, h3 + ke);
      } else
        L2(n.tabConvert ? S2 : "	");
    }
    function B() {
      let { selectionStart: p3, selectionEnd: h3, value: m2 } = s2, _ = m2.lastIndexOf(`
`, p3 - 1) + 1, I2 = jt(m2, h3), H = s2.value.slice(_, I2), ge = H.replace(/(^|\n)(\t| {1,2})/g, "$1"), ye = H.length - ge.length;
      s2.setSelectionRange(_, I2), L2(ge);
      let Ae = /\t| {1,2}/.exec(m2.slice(_, p3)), ke = Ae ? Ae[0].length : 0, pn = p3 - ke;
      s2.setSelectionRange(p3 - ke, Math.max(pn, h3 - ye));
    }
    function V(p3) {
      a2 = new un.Textcomplete(new cn.TextareaEditor(s2), p3, { dropdown: { maxCount: 12, rotate: true } }), u2 = document.querySelector(".textcomplete-dropdown"), a2.on("selected", () => {
        s2.value[s2.selectionEnd] === '"' && (s2.selectionStart += 1);
      });
    }
  }
  function Je(r, e2) {
    let t = xe(e2), i2 = r.getAttribute("data-papyrus");
    i2 !== null && (i2 === "editor" && t.editor === false ? (t.editor = _e(true), t.startMode = "editor") : i2 === "static" && t.editor !== false && (t.startMode = "static"));
    let n = je(t);
    n.nodes(r), n.language(t.language);
    let a2 = "";
    t.input !== void 0 && t.input.length > 0 ? a2 = ce(t.input, t) : a2 = ce(n.code.textContent || "", t), t.lineNumbers && (n.code.classList.contains("line-numbers") ? n.lines = ne(a2) : (n.code.classList.add("line-numbers"), n.lines = ne(a2))), n.highlight(a2), t.editor ? n.pre.setAttribute("data-papyrus", "editor") : n.pre.setAttribute("data-papyrus", "static"), n.code.style.position === "initial" && (n.code.style.setProperty("position", "absolute"), n.pre.style.setProperty("height", `${n.code.offsetHeight}px`));
    let o2 = dn(n, t);
    return t.editor && t.startMode === "editor" && o2.textarea.style.position === "relative" && o2.textarea.style.setProperty("position", "relative"), n.model.set(n.pre.id, o2), o2;
  }
  function At(r, e2) {
    let t = xe(e2), i2 = je(t), n = ce(r, e2);
    if (t.language === null)
      return console.error("\u{13041} Papyrus: Missing Language Reference"), n;
    i2.language(t.language);
    let a2 = [], o2 = t.addClass.pre.join(" ").trimEnd(), b2 = t.addAttrs.pre.join(" "), s2 = t.addClass.code.join(" ").trimEnd(), S2 = t.addAttrs.code.join(" "), E = t.lineNumbers ? "" : "no-fence";
    if (t.addAttrs.pre.length > 0) {
      let c = `papyrus ${E} ${o2}`.trimEnd();
      t.editor ? a2.push(`<pre class="${c}" ${b2} data-papyrus="editor">`) : a2.push(`<pre class="${c}" ${b2}> data-papyrus="static"`);
    } else if (t.editor) {
      let c = `papyrus ${E} ${o2}`.trimEnd();
      a2.push(`<pre class="${c}" data-papyrus="editor">`);
    } else {
      let c = `papyrus ${E} ${o2}`.trimEnd();
      a2.push(`<pre class="${c}" data-papyrus="static">`);
    }
    if (t.lineNumbers) {
      let c = `language-${t.language} line-numbers ${s2}`.trimEnd();
      t.addAttrs.code.length > 0 ? a2.push(`<code class="${c}" ${S2}>`) : a2.push(`<code class="${c}">`);
    } else {
      let c = `language-${t.language} ${s2}`.trimEnd();
      t.addAttrs.code.length > 0 ? a2.push(`<code class="${c}" ${S2}>`) : a2.push(`<code class="${c}">`);
    }
    return a2.push(i2.raw(n), "</code>", "</pre>"), a2.join("");
  }
  var fe = function(e2) {
    if (document.readyState === "loading")
      return;
    let t = document.querySelectorAll("pre");
    if (t.length > 0)
      for (let i2 of t)
        Je(i2, e2);
    return Array.from(re.values());
  };
  function dr() {
    return Array.from(re.values());
  }
  function pr(r) {
    if (typeof r == "string") {
      if (re.has(r))
        return re.get(r);
      console.error(`\u{13041} Papyprus: No code (<pre>) element using id: "${r}"`);
    } else
      throw new Error(`\u{13041} Papyprus: Invalid id parameter type, expected string, recevied: ${typeof r}`);
    return null;
  }
  function fr(r, e2, t) {
    let i2 = xe(t), n = At(r, i2), a2 = typeof e2 == "string" ? document.querySelector(e2) : e2;
    return a2.innerHTML = n, Je(a2, i2);
  }
  typeof window != "undefined" && Ce("Papyprus", window) === false && Object.defineProperty(window, "Papyrus", { get() {
    return re;
  } });
  Ce("model", fe) === false && Object.defineProperty(fe, "model", { get() {
    return re;
  } });
  fe.get = pr;
  fe.list = dr;
  fe.render = fr;
  fe.mount = Je;
  fe.static = At;
  var ki = fe;

  // src/app/components/methods.ts
  var Methods = class extends spx.Component {
    onmount() {
      this.methods = j(this.dom.relapseNode, {
        multiple: true,
        persist: false
      });
      this.methods.on("toggle", (fold) => {
        if (fold.expanded) {
          this.collapse({ attrs: { fold: fold.index } });
        } else {
          this.expand({ attrs: { fold: fold.index } });
        }
      });
      this.code();
    }
    code() {
      this.dom.renderNode.innerHTML = ki.static(JSON.stringify({
        multiple: this.methods.options.multiple,
        persist: this.methods.options.persist,
        fold: {
          easing: "ease-in-out",
          duration: this.methods.options.fold.duration
        },
        fade: {
          duration: this.methods.options.fade.duration,
          transition: "linear"
        }
      }, null, 2), {
        language: "javascript",
        lineNumbers: false,
        editor: false
      });
    }
    options({ attrs, target }) {
      if (attrs.type === "fade") {
        this.methods.config({ fade: { duration: +target.value } });
        this.dom.fadeDurationNode.innerText = `${this.methods.options.fade.duration}`;
      } else if (attrs.type === "fold") {
        this.methods.config({ fold: { duration: +target.value } });
        this.dom.foldDurationNode.innerText = `${this.methods.options.fold.duration}`;
      } else if (attrs.type === "multiple") {
        this.methods.config({ multiple: target.checked });
      } else if (attrs.type === "persist") {
        this.methods.config({ persist: target.checked });
      }
      this.code();
    }
    expand({ attrs }) {
      this.methods.expand(attrs.fold);
      this.dom.openerNodes[attrs.fold].classList.add("disabled");
      this.dom.openerNodes[attrs.fold].classList.remove("active");
      this.dom.closerNodes[attrs.fold].classList.remove("disabled");
      this.dom.closerNodes[attrs.fold].classList.add("active");
    }
    collapse({ attrs }) {
      this.methods.collapse(attrs.fold);
      this.dom.openerNodes[attrs.fold].classList.remove("disabled");
      this.dom.closerNodes[attrs.fold].classList.remove("active");
      this.dom.closerNodes[attrs.fold].classList.add("disabled");
    }
    disable({ attrs }) {
      this.methods.expand(attrs.fold);
    }
  };
  Methods.define = {
    state: {
      open: {
        default: 0,
        typeof: Number
      }
    },
    nodes: [
      "relapse",
      "opener",
      "closer",
      "render",
      "foldDuration",
      "fadeDuration"
    ]
  };

  // src/app/components/events.ts
  var Events = class extends spx.Component {
    constructor() {
      super(...arguments);
      this.colors = ["fc-cyan", "fc-pink", "fc-purple", "fc-green"];
    }
    onmount() {
      this.relapse = j(this.dom.relapseNode);
      this.relapse.on("focus", this.focus, this);
      this.relapse.on("collapse", this.collapse, this);
      this.relapse.on("expand", this.expand, this);
      this.relapse.on("toggle", this.toggle, this);
    }
    insert(message, fold) {
      ++this.state.count;
      const element2 = document.createElement("div");
      element2.className = `d-block pb-1 message ${this.colors[fold]}`;
      element2.ariaLabel = `${this.state.count}`;
      element2.innerText = message;
      this.dom.logNode.appendChild(element2);
      this.dom.logNode.scrollTop = this.dom.logNode.scrollHeight;
    }
    toggle(fold) {
      this.insert(
        `Fold at index ${fold.index} was toggled and will ${fold.expanded ? "collapse" : "expand"}`,
        fold.index
      );
    }
    focus(fold) {
      this.insert(
        `Fold at index ${fold.index} was focused and will ${fold.expanded ? "collapse" : "expand"}`,
        fold.index
      );
    }
    collapse(fold) {
      this.insert(
        `Fold at index ${fold.index} was collapsed and is closed`,
        fold.index
      );
    }
    expand(fold) {
      this.insert(
        `Fold at index ${fold.index} was expanded and is open`,
        fold.index
      );
    }
  };
  Events.define = {
    state: {
      count: Number
    },
    nodes: [
      "relapse",
      "log"
    ]
  };

  // src/app/components/dropdown.ts
  var Dropdown = class extends spx.Component {
    /**
     * Returns all `<label>` elements in the dropdown
     */
    inViewport() {
      const rect = this.dom.collapseNode.getBoundingClientRect();
      for (const { element: element2, folds } of j.get()) {
        if (element2.id === this.state.accordion) {
          if (!(rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth))) {
            folds.find((fold) => fold.expanded === true).close();
          }
          break;
        }
      }
    }
    /**
     * Toggle - Open/Close
     */
    toggle(event) {
      event.stopPropagation();
      if (this.root.classList.contains("is-open"))
        return this.close();
      this.state.collapse = "opened";
      this.root.classList.add("is-open");
      this.dom.buttonNode.classList.remove("selected");
      if (this.state.hasAccordion)
        this.inViewport();
      addEventListener("click", this.outsideClick.bind(this));
    }
    /**
     * Click detected outside, eg: document body
     */
    outsideClick(event) {
      if (this.dom.buttonNode !== event.target && this.dom.collapseNode !== event.target) {
        if (this.root.classList.contains("is-open")) {
          this.close();
        }
      }
    }
    /**
     * Close Dropdown
     */
    close() {
      this.root.classList.remove("is-open");
      if (this.state.collapse === "selected" || this.state.hasSelected) {
        this.root.classList.add("selected");
        this.state.collapse = "selected";
      } else {
        this.state.collapse = "closed";
      }
      removeEventListener("click", this.outsideClick);
      this.dom.buttonNode.focus();
    }
    /**
     * Select Inputs
     *
     * Used for Dropdown Forms
     */
    select({ target }) {
      target.checked = true;
      this.state.selected = target.value;
      this.dom.buttonNode.innerText = target.getAttribute("aria-label");
      this.state.collapse = "selected";
      for (const label of this.root.getElementsByTagName("label")) {
        if (label.getAttribute("for") === target.id) {
          if (!label.classList.contains("selected")) {
            label.classList.add("selected");
          }
        } else {
          if (label.classList.contains("selected")) {
            label.classList.remove("selected");
          }
        }
      }
      this.close();
    }
    /**
     * Items in dropdown - An ul > li <select> element equivelent
     */
    option(event) {
      if (event.target instanceof HTMLElement) {
        if (event.currentTarget instanceof HTMLElement) {
          const [selected] = event.currentTarget.getElementsByClassName("selected");
          if (selected)
            this.state.selected = selected.id;
        }
        if (event.currentTarget instanceof HTMLElement) ;
        if (this.state.hasRequired) {
          if (this.dom.buttonNode.classList.contains("is-invalid")) {
            this.dom.buttonNode.classList.remove("is-invalid");
          }
          this.state.required = false;
          this.dom.buttonNode.classList.add("selected");
        }
        if (this.state.kind === "preset") {
          this.state.selected = `Preset (${event.target.textContent.trim()})`;
          this.dom.buttonNode.innerHTML = `Preset (${event.target.textContent.trim()})<span class="icon"></span>`;
        } else {
          this.state.selected = event.target.textContent;
          this.dom.buttonNode.textContent = event.target.textContent;
        }
        for (const node of this.dom.collapseNode.children) {
          if (node.id !== event.target.id) {
            node.classList.remove("selected");
          } else {
            node.classList.add("selected");
          }
        }
        this.state.collapse = "selected";
        this.toggle(event);
      }
    }
    /* -------------------------------------------- */
    /* TYPES                                        */
    /* -------------------------------------------- */
  };
  Dropdown.define = {
    state: {
      selected: String,
      form: String,
      accordion: String,
      kind: String,
      required: {
        typeof: Boolean,
        default: false
      },
      collapse: {
        typeof: String,
        default: "closed"
      },
      type: {
        typeof: String,
        default: "dropdown"
      }
    },
    nodes: [
      "collapse",
      "button"
    ]
  };

  // src/app/bundle.ts
  spx(
    {
      fragments: [
        "main",
        "menu"
      ],
      components: {
        Methods,
        Dropdown,
        Events,
        Tabs,
        Drawer
      }
    }
  )(function() {
    j();
  });
  spx.on("load", function({ key }) {
    j.reinit();
  });
  /**
  * SPX ~ Single Page XHR | https://spx.js.org
  *
  * @license CC BY-NC-ND 4.0
  * @version 0.1.2-beta.1
  * @copyright 2024 Nikolas Savvidis
  */

})();
